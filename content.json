{"meta":{"title":"Honly's Blog","subtitle":"Stay hungry. Stay foolish.","description":null,"author":"Honly","url":"http://guanhonly.github.io"},"pages":[],"posts":[{"title":"轨迹压缩算法(Polyline encoding algorithm)探究","slug":"PolylineEncoding","date":"2019-09-05T12:17:10.000Z","updated":"2019-09-06T15:27:25.999Z","comments":true,"path":"2019/09/05/PolylineEncoding/","link":"","permalink":"http://guanhonly.github.io/2019/09/05/PolylineEncoding/","excerpt":"","text":"前言文中的代码表达采用Java一般来说，轨迹是由若干个轨迹点组成的数组来表达的，每个轨迹点可以表达为 $p = (x, y, t, A)$。其中 $x, y$ 是其空间坐标（一般来说，空间坐标用经纬度表示，即$x$一般对应经度(longitude)，$y$一般对应纬度(latitude)），$t$是记录这个轨迹点的时间戳(Timestamp), $A$则是这个轨迹点的属性。如果只想保留一个轨迹点最基本的信息，则只需要保留其空间信息和时间信息，即可以将一个轨迹点表示为 $p = (x, y, t)$。在写代码时，一个轨迹点的类型可以定义如下： 12345class PointTs &#123; double lng; double lat; long timestamp;&#125; 而这样保存一个轨迹点，$x$和$y$一般使用double类型，$t$一般使用long类型，再加上至少3个字符的分隔符（分隔x,y,t和每个轨迹点），一个轨迹点就要占 Double.SIZE * 2 + Long.SIZE + Character.SIZE * 3 == 27 * Byte.SIZE, 也就是说保存一个轨迹点至少需要占27个字节。在如今轨迹数量越来越大的情况下，有必要使用轨迹压缩的算法来解决轨迹数据量过大的问题。在查阅了资料后，我在Google地图开发平台中看到了Google采用的轨迹数据压缩算法，名为Polyline encoding algorithm（需要科学上网），可以将若干个轨迹点编码成一串字符串，并且实现轨迹的压缩。这是一个有损的压缩算法，并且可以压缩有符号的数字。接下来我将从编码和解码两个方面解析这个算法，并给出示例代码。 编码这种编码其实主要是针对数字来编码的，比如说，有一个经度为：-179.9832104 对于这样的浮点型数字，首先需要做的是想办法去掉其小数点。所以，可以预设一个10的整数倍的值来与这个浮点数相乘，并取得整数。 在这里，我预设这个值为$10^5$，将这个经度乘以$10^5$，得到：-17998321 将上一步得到的整数转换成二进制，由于我们的值是负数，得到的是17998321的补码：11111110 11101101 01011110 00001111 将二进制数左移一位：11111101 11011010 10111100 00011110 如果原来的数是负数，则取反码：00000010 00100101 01000011 111000013、4两步的目的是为了区分正负数，这样做后，负数的最后一位都是1，正数的最后一位都是0 从右到左，每5位分为一组（一组称为一个chunk）：00001 00010 01010 10000 11111 00001这样可以舍弃高位的0，节约空间。 将这些分组顺序反转（reverse order）：00001 11111 10000 01010 00010 00001这样做的目的是在写代码时可以每次从低位取数据，更适合代码实现。因为一般而言，写代码读二进制时，读高位比较复杂，而读低位较简单（例如，读最后五位只需要 &amp;0x1F），读到最后几位后可以直接append到结果中，不用插入到结果的前端，效率更高。 除了最后一个chunk，其他chunk和0x20进行或操作：100001 111111 110000 101010 100010 000001这一步的目的是保证只有最后一个chunk是小于0x20的。起到了分隔的作用。 分别将每个二进制的chunk转化为十进制的数字：33 63 48 42 34 1 对每个数字都加上63：96 126 111 105 97 64由于ASCII码前63位中有很多不可显示的控制符（比如NULL、换行符之类的），并且第127个是删除符，所以这一步将数字范围控制在了64~126之间。 将数字转化成ASCII表中对应的字符： 1`~oia@ 其实如果单独对一个数字来说，这个方法的压缩率并不高，有时候还会得不偿失。比如上述的数字-179.9832104，使用这种方法压缩后成为5个字符，占5个字节。如果将直接乘以$10^5$，可以直接用有符号的整型表示，还只占4个字节呢！所以，这个算法还有一个思想就是：后一个值用其与前一个值的差值表示，由于差值比较小，所以在上述的第5步时可以将高位的零舍弃掉，节省空间。下面是Google地图开发平台中给出的例子： 可以看到，这个例子中存储一个点只存储了其空间信息（经纬度），除了第一个点之外，后面的点都是存储的偏移量。 解码解码其实就比较简单了，相当于把编码步骤倒过来执行一遍。编码中的步骤4可以使得我们在解码时知道这个数字是正数还是负数，步骤7可以让我们知道数字的边界在哪。 Talk is cheap, show me the code原理知道了之后，代码就比较简单了，贴一个我写的代码：SimpleTrajectoryCompressor","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"http://guanhonly.github.io/tags/GIS/"},{"name":"算法","slug":"算法","permalink":"http://guanhonly.github.io/tags/算法/"},{"name":"Google","slug":"Google","permalink":"http://guanhonly.github.io/tags/Google/"},{"name":"轨迹","slug":"轨迹","permalink":"http://guanhonly.github.io/tags/轨迹/"}]},{"title":"Ubuntu16.04+1080ti显卡驱动循环登录问题解决办法","slug":"nvidia-driver-error","date":"2019-04-20T14:35:42.000Z","updated":"2019-09-05T17:55:36.120Z","comments":true,"path":"2019/04/20/nvidia-driver-error/","link":"","permalink":"http://guanhonly.github.io/2019/04/20/nvidia-driver-error/","excerpt":"","text":"昨天发现Ubuntu在登录界面循环登录，百度之后说是显卡驱动问题，于是将显卡驱动卸了，可是之后却再也装不上，装上了之后又循环登录了。 机器情况是两块NVIDIA 1080Ti，Ubuntu16.04系统。为了解决这个问题，百度、Google搜了半天，发现了一个写的很好的帖子Ubuntu16.04+1080ti显卡驱动安装流程+循环登录问题，上面的所有方法试过之后并没有什么卵用，尝试在NVIDIA官网上下载驱动后手动安装，发现提示gcc版本不对，起初没有关注这个问题，最终实在是没有办法，安装了对应版本的gcc，然后就好了。。。 所以，如果在网上搜到的所有方法都没奏效的话，不妨试试我的这个方法： 卸载旧显卡驱动： 1sudo apt-get remove --purge nvidia* 卸载旧gcc: 1sudo apt-get remove gcc 安装新gcc: 1sudo apt-get install gcc 安装新驱动： 1sudo apt-get install nvidia-418 //我这里根据我的显卡型号下载的，对应驱动型号可以在英伟达官网查找 重启 然后就大功告成了。","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"实用教程","slug":"实用教程","permalink":"http://guanhonly.github.io/tags/实用教程/"}]},{"title":"Google s2 lib研究之空间覆盖","slug":"s2-approximate-polygon-by-cell","date":"2019-03-30T13:07:54.000Z","updated":"2019-09-05T18:06:12.358Z","comments":true,"path":"2019/03/30/s2-approximate-polygon-by-cell/","link":"","permalink":"http://guanhonly.github.io/2019/03/30/s2-approximate-polygon-by-cell/","excerpt":"","text":"本文适合于对Google s2有一定了解或对空间索引有一定了解的读者。 空间索引常用的方法是空间填充曲线，比如Hilbert, Geohash等，被用于许多查询场景中。Google也推出了自己的空间索引——Google s2，这个项目是一个开源项目，有兴趣的可以直接看Google s2 java版源码和官方文档。对Google s2的介绍可以看Google’s S2, geometry on the sphere, cells and Hilbert curve，中文的可以看高效的多维空间点索引算法 — Geohash 和 Google S2。关于Google s2的基本原理在此就不再赘述，本文主要讲s2中一个重要的算法——空间覆盖。 可能这个算法名称乍一看有点一头雾水，在这里截取一张官方文档中的图： 意思就是，使用若干个s2定义的空间单元去逼近一个任意形状的区域，这些空间单元可能大小不一，并且可以设置最大的空间单元、最小的空间单元和空间单元数量。 官方文档没有给出其原理，在看了Google s2的源码之后，终于对这个算法有了一个初步的了解。 在讲算法之前，先说几点重要的概念： 每个非最底层的空间单元（简称cell，下同）都有四个子cell，即在Google s2中空间索引是四叉树的形式； 每个cell都有其特定的id，id的命名方法请参考官方文档。 接下来开始说算法： 算法输入是一个空间区域region，cell的最小层级minLevel和最大层级maxLevel，返回cell的数量maxCells，返回结果是cell id的集合result。源代码中有一个十分重要的函数addCandidate，过程有点复杂，在之后讲。在此只描述maxCells大于等于4且层级粒度为1时（特定条件）的主体算法。 定义一个优先队列candidateQueue，用于存储cell。其中排序的依据按照cell的权重由大到小排列，cell的权重计算方法后面讲。 初始化candidateQueue：用四个cell完全覆盖region的最小外包圆，这四个cell是同一层级的刚好能覆盖region的四个cell，即如果cell的层级再高一层，就不能完全覆盖region。对这四个cell执行addCandidate函数。 弹出candidateQueue的队首元素candidate，如果candidate的层级小于最小层级 || candidate的与region相交的子cell的数量只有1个 || resul.size()+candidateQueue.size()+candidate的与region相交的孩子的数量 &lt;= maxCells，则对candidate的与region相交的所有子cell执行addCandidate函数；否则将该candidate的id插入到result中。 如果candidateQueue不为空且result中元素的数量小于maxCells，则返回步骤3；否则结束算法。 接下来讲一下重点：addCandidate函数 addCandidate函数的源码如下（在本文中，根据特定条件作了一点修改，以方便读者理解）： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Process a candidate by either adding it to the result list or expanding its * children and inserting it into the priority queue. Passing an argument of * NULL does nothing. */ private void addCandidate(Candidate candidate) &#123; if (candidate == null) &#123; return; &#125; if (candidate.isTerminal) &#123; result.add(candidate.cell.id()); return; &#125; // Expand one level at a time until we hit min_level_ to ensure that // we don't skip over it. int numLevels = (candidate.cell.level() &lt; minLevel) ? 1 : levelMod; int numTerminals = expandChildren(candidate, candidate.cell, numLevels); if (candidate.numChildren == 0) &#123; // Do nothing &#125; else if (numTerminals == 1 &lt;&lt; 2 &amp;&amp; candidate.cell.level() &gt;= minLevel) &#123; // Optimization: add the parent cell rather than all of its children. candidate.isTerminal = true; addCandidate(candidate); &#125; else &#123; // We negate the priority so that smaller absolute priorities are returned // first. The heuristic is designed to refine the largest cells first, // since those are where we have the largest potential gain. Among cells // at the same level, we prefer the cells with the smallest number of // intersecting children. Finally, we prefer cells that have the smallest // number of children that cannot be refined any further. int priority = -((((candidate.cell.level() &lt;&lt; 2 + candidate.numChildren) &lt;&lt; 2) + numTerminals); candidateQueue.add(new QueueEntry(priority, candidate)); &#125; &#125; 从代码中可以看到，如果candidate被标记了isTerminal，就可以直接加入到result中，cell被标记isTerminal的条件是： cell被region完全包含 cell再向下剖分后层级会超过maxLevel 其中expandChildren函数是获取一个cell有会被标记为isTerminal的子cell数量，这个数量被记为numTerminals。如果一个cell的所有子cell全被标记为isTerminal，则直接将这个cell加入到result中（这个是一个优化项（Optimization），再向下划分毫无意义，这样做减小了算法复杂度）；否则将这个cell加入到candidateQueue中，其中优先级的计算方法我至今没搞懂，有弄懂的欢迎评论，优先级的计算转换为数学公式如下：$$priority = -（(level \\times 4 + numChildren)\\times 4 + numTerminals）$$其中level表示这个cell的层级，numChildren表示这个cell的和region相交的子cell数量。candidateQueue按照这个优先级由高到低排列。 做一个总结：这个算法相当于先将初始的cell（保证能完全覆盖region的cell，一般为4个）压入candidateQueue中，然后不断地从candidateQueue中获取需要处理的cell。如果cell有需要处理的子cell则将其子cell加入队列，如果cell已不需要处理则直接插入到结果列表中。直到candidateQueue为空或者result中元素的数量达到预设的 以上就是我从Google s2的java版源码中看到的空间覆盖算法，在给出了的测试有如下效果： 后来翻到了有人给出了更详细的s2空间覆盖源码剖析，是Go语言的：Google S2 是如何解决空间覆盖最优解问题的?","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"http://guanhonly.github.io/tags/GIS/"},{"name":"算法","slug":"算法","permalink":"http://guanhonly.github.io/tags/算法/"},{"name":"Google","slug":"Google","permalink":"http://guanhonly.github.io/tags/Google/"},{"name":"空间索引","slug":"空间索引","permalink":"http://guanhonly.github.io/tags/空间索引/"}]},{"title":"XZ曲线探究","slug":"XZOdering","date":"2018-12-27T13:51:59.000Z","updated":"2019-01-10T08:19:26.092Z","comments":true,"path":"2018/12/27/XZOdering/","link":"","permalink":"http://guanhonly.github.io/2018/12/27/XZOdering/","excerpt":"","text":"最近在做时空数据库相关的项目，需要做一些空间索引的工作，于是研究了一番GeoMesa和GeoWave。发现他们专门为Polygon类型数据使用了一种叫做XZ曲线的索引。空间填充曲线对于一个GISer来说十分熟悉，但XZ曲线确实是之前闻所未闻。根据GeoMesa的介绍，找到了XZ曲线的论文。论文写得晦涩难懂，看了半天仍未完全看明白。于是又去看GeoWave中关于XZ曲线的源码，终于将XZ的基本原理大致搞懂了。 本文使用的名词解释：cell: 传统Z曲线的格网单元element: XZ曲线的格网单元level: 层级g: 最大分辨率，即最大层级object: 对象，即需要存储的要素对象quadrant sequences: 象限序列，即传统Z曲线的编码interval: 一个区间(查询时使用)interval set: 区间集合（查询时使用） 空间填充曲线首先说一下空间填充曲线。空间填充曲线是一种将高维空间映射到一维空间的方法,经典的空间填充曲线有Z曲线、Hilbert曲线等，现在Google S2也经常被使用。Z曲线最常见的应用就是GeoHash，Hilbert常和四叉树结合使用。关于GeoHash和Google s2可以参考高效的多维空间点索引算法 — Geohash 和 Google S2，Hilbert可以参考Hilbert曲线介绍以及代码实现。 空间填充曲线将空间进行划分为一个个小格网，一般对这些小格网称为cell。在这里引入层级level的概念，level越高，对空间进行的划分越精细，即level越高，cell的大小越小，数量越多。 Z曲线Z曲线是一种空间填充曲线。在Z曲线中，level 1将空间划分为四个cell，level 2则将level 1中的每个cell进行四等分，生成的cell的长宽是其parent cell的一半，即level 2中有16个格网。则在level n中，存在$(2^2)^n$个cell。 Z曲线更加直观地显示如图1。 XZ曲线是由Z曲线衍生出来的，首先说明一下论文中对Z曲线及其编码的定义，以及作者认为的传统Z曲线的缺点： Z曲线的cell按照象限序列（quadrant sequences，本文沿用论文名词）进行编码，即传统的Z曲线编码（见图2）。 将数据空间归一化为经纬度范围均为1的正方形，即将整个需要编码的空间作为一个边长为1的正方形，并具有x轴和y轴。则level n中每个cell的边长为$0.5^n$。 如果有很小的要素恰好在数据空间的正中心，则象限序列会为空（如图3）。 XZ曲线鉴于Z曲线的缺点，XZ曲线具有以下特性： 基本的单元（论文中称为element，本文沿用论文名词）为传统Z曲线cell向右上边长扩大一倍，这样使得临近的element之间存在50%的重叠度(如图4)。 element的数量和cell的数量一致，即边界也向外延伸。 存储的要素不作冗余存储，即单个要素只存储于一个element中。 对于XZ曲线的一些性质和论文中给出的一些定理，本文不加证明地罗列出来，如果感兴趣可以去论文中查看证明过程。 XZ曲线最大的一个特点就是将cell向右上扩大为element，关于element论文中有一个定义：定义1 设一个element的左下角cell的quadrant sequences为$s$，$|s|$为其长度，则element的边长为${0.5}^{|s|-1}$。 由于一个对象（文中称为对象object，本文沿用论文名词）只存储在一个element中，则一个object最多只和一个cell的两条边相交。则具有以下定理： 定理1 设$\\lvert s\\rvert$为一个quadrant sequences $s$的长度，w为一个object的宽度，h为一个object的高度。则$\\lvert s\\rvert$的范围为： $$l_1 \\le \\lvert s\\rvert \\lt l_2，其中 \\ l_1 = \\lfloor log_{0.5}(max\\{w,h\\}) \\rfloor,\\ l_2 = l_1 + 2$$ 由于不作冗余存储，一个object直接存储于一个element中，相当于使用一个element去逼近object,造成的误差会比较大。在论文中也写出了误差指标和XZ曲线的误差。设object的实际面积为$S_{obj}$，使用一个element进行存储时element的实际面积为$S_{ele}$，则逼近误差为：$$ E_{rel} = \\frac{S_{ele}-S_{obj}}{S_{obj}} $$XZ曲线的最大逼近误差小于15。 设最大level为g，则对于一个level $l$的cell，其具有的level g后代数量为：$$ N_{cell}(l) = 4^{g-l} $$则可求出，对于一个level $l$的cell，其具有的所有level的后代数量，是为定理2： 定理2 对于一个quadrant sequences $s$所代表的cell（level为$l$），其具有的所有level的element后代数量（包括当前对应的element，最大level为g)为：$$ N_{ele} = \\frac{4^{g-l+1}-1}{3} $$ 接下来就是最重要的一条定义，是XZ曲线的编码，称为sequence code： 定义2 对于一个quadrant sequences $s = \\langle \\ q_0 \\ q_1 \\ … \\ q_i \\ … \\ q_{l-1} \\ \\rangle$，可以得到其对应的XZ曲线编码为：$$ C(s) = \\sum_{0\\le i \\lt l} q_i \\cdot \\frac{4^{g-i}-1}{3}+1 $$ 论文中对XZ曲线编码推论出了两个定理：定理3 对于quadrant sequences $s$所对应的XZ编码值$C(s)$，其大小代表了$s$的字典序位置，即：$$ s_1 \\lt_{lex} s_2 \\Longleftrightarrow C(s_1) \\lt C(s_2) $$ 定理4 从quadrant sequences映射到数值型编码的方法中，sequence code具有最好的临近性。即相近的两个quadrant sequences对应的sequence code值最相近。 XZ曲线的插入操作将object转换为XZ编码，首先需要确定object对应的层级。根据定理1，一个object所在的层级为$l_1 = \\lfloor log_{0.5}(max\\{w,h\\})\\rfloor$或$l_1+1$。设$x_l$为object的x下界，w为object的宽度，$y_l$为object的y下界，h为object的宽度，$w_2 = {0.5}^{l_1+1}$。则可根据以下两个式子可判断object的层级$l$：$$ x_l + w \\le \\lfloor \\frac{x_l}{w_2} \\rfloor \\cdot w_2 + 2w_2 $$$$ y_l + h \\le \\lfloor \\frac{y_l}{w_2} \\rfloor \\cdot w_2 + 2w_2 $$注：这个不等式和论文上不一致，经过讨论发现应该是论文出错，此处公式使用的是GeoWave源码中的公式若以上两式同时成立，则object的层级$l = l_1 + 1$，否则$l = l_1$ XZ曲线的查询操作XZ曲线查询得到的结果是一个区间集合（interval set，本文沿用论文名词），interval set中的一个interval代表一个element中所有后代element的集合，即interval表示的是sequence code范围。 关于XZ曲线的查询生成interval set，论文中表述得较少并且不明确，GeoWave源码也没有完全按照论文中的方法来实现。本着实事求是的原则，以下按照GeoWave源码的方法讲述XZ曲线查询操作。 查询的方法为：给定一个查询框，如果查询框和包含某个element，则将该element对应的interval（即其所有后代element）加入到interval set中；如果查询框与某个element相交，则将该element作为一个interval（这个interval中只有这个element对象）加入到interval set中，并将这个element分裂为其子element，再和查询框进行拓扑关系判断，直至interval set中的数量达到给定的阈值或分裂至最大层级。得到interval set后，将其中有交集的interval进行合并，生成最终的interval set。 查询的伪代码如下：123456789101112131415161718192021222324252627282930313233343536Queue&lt;Element&gt; remaining; // 待处理队列List&lt;Interval&gt; intervalSet; // 最终结果remaining.add(LevelOneElement); // 加入第一层的elementremaining.add(LevelTerminator); // 加入一层的终止条件while (level &lt; g &amp;&amp; !remaining.empty() &amp;&amp; intervalSet.size() &lt; maxSize) &#123; Element next = remaining.poll(); if (next == LevelTerminator) &#123; if (!remaining.isEmpty()) &#123; level = level + 1; remaining.add(LevelTerminator); &#125; &#125; else &#123; if (query.contain(next)) &#123; intervalSet.add(interval(next)); &#125; else if (query.intersect(next)) &#123; intervalSet.add(next); remaining.add(next.children()); &#125; &#125;&#125;// 兜底策略，将未处理完的element处理完while (!remaining.empty()) &#123; Element next = remaining.poll(); if (next == LevelTerminator) &#123; level = level + 1; &#125; else &#123; intervalSet.add(interval(next)); &#125;&#125;mergeIntervalsWhichAreIntersected(intervalSet); 以上就是XZ曲线的基本原理，感觉目前XZ曲线使用得很少，几乎查不到相关资料，只能根据原始论文和GeoWave实现的源码去慢慢摸索。希望我的这篇博文可以帮助大家理解XZ曲线，如果有疑问和建议可以在评论中指出！ Acknowledgement感谢同组的@Louis Liu和我一起看XZ曲线的论文和源码（他没有GitHub和微博账号，只能这么感谢了😂）","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"http://guanhonly.github.io/tags/GIS/"},{"name":"空间填充曲线","slug":"空间填充曲线","permalink":"http://guanhonly.github.io/tags/空间填充曲线/"}]},{"title":"（转载）Python基础","slug":"python-learn-1","date":"2018-12-03T10:35:12.000Z","updated":"2018-12-03T11:18:49.949Z","comments":true,"path":"2018/12/03/python-learn-1/","link":"","permalink":"http://guanhonly.github.io/2018/12/03/python-learn-1/","excerpt":"","text":"转载自：Python基础长文 一、Day10.print123name = input(\"What is your name?\")print(\"Hello \"+name )# 或者print(\"Hello\",name ),print中逗号分隔直接将字符串用空格分隔，若用+号连接，并且想留空格，则在前一字符串留空格即可 1.输入输出123username=input(\"username:\")password=input(\"password:\")print(username,password) 2.格式输入输出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 第一种方法name=input(\"Name:\")age=input(\"age:\")job=input(\"job:\")info='''---------info of ---------''' + '''Name:'''+name+'''Age:'''+age+'''Job:'''+jobprint(info)# 第二种方法name=input(\"Name:\")age=int(input(\"age:\")) #如果不用int()就会报错(虽然输入为数字，但是print(type(age))为str型)，因为python如果不强制类型转化，就会默认字符型job=input(\"job:\")info='''---------info of ---------Name:%sAge:%dJob:%s'''%(name,age,job)print(info)# 第三种方法name=input(\"Name:\")age=int(input(\"age:\")) #如果不用int()就会报错(虽然输入为数字，但是print(type(age))为str型)，因为python如果不强制类型转化，就会默认字符型job=input(\"job:\")info='''---------info of ---------Name:&#123;_name&#125;Age:&#123;_age&#125;Job:&#123;_job&#125;'''.format(_name=name,_age=age,_job=job)print(info)# 第四种方法name=input(\"Name:\")age=int(input(\"age:\")) #如果不用int()就会报错(虽然输入为数字，但是print(type(age))为str型)，因为python如果不强制类型转化，就会默认字符型job=input(\"job:\")info='''---------info of ---------Name:&#123;0&#125;Age:&#123;1&#125;Job:&#123;2&#125;'''.format(name,age,job)print(info) 3.输入密码不可见123import getpasspwd=getpass.getpass(\"请输入密码:\")print(pwd) 4.验证，python缩进12345678_username='Alex Li'_password='abc123'username=input(\"username:\")password=input(\"password:\")if _username==username and _password==password: print((\"Welcome user &#123;name&#125; login...\").format(name=username))else: print(\"Invalid username or password!\") 5.指向—修改字符串123456789print(\"Hello World\")name = \"Alex Li\"name2=nameprint(name)print(\"My name is\", name,name2) # Alex Li Alex Liname = \"PaoChe Ge\"# name2=name指的是name2与name一样指向Alex Li的内存地址，name指向改了，但是name2不变print(\"My name is\", name,name2) # PaoChe Ge Alex Liprint(\"您好，我来了\") 6.注释`‘’’ ‘’’`内涵123456789# 第一种情况就是注释'''print(\"这是一行注释\")'''#第二种情况就是打印多行字符串str='''这是第一行内容这是第二行内容'''print(str)# 3.单套双，双套单都可以str1=\"i'am a student\"print(str1) 7.模块初始sys与os123456789101112131415161718192021222324import sys# 打印环境变量print(sys.path)print(sys.argv)print(sys.argv[2])# 进度条import timefor i in range(50): sys.stdout.write('#') sys.stdout.flush() time.sleep(0.5)import oscmd_res = os.system(\"dir\") # os.system()执行后直接输出到终端，然后结束，最后cmd_res保存的是os.system()执行后的状态码print(\"---&gt;\",cmd_res) # ---&gt; 0cmd_res1=os.popen(\"dir\")print(\"---&gt;\",cmd_res1) # 得到的是内存对象值 ---&gt; &lt;os._wrap_close object at 0x00000000029187B8&gt;cmd_res1=os.popen(\"dir\").read()print(\"---&gt;\",cmd_res1) # 读取数据必须再后面加个read()os.mkdir(\"new_dir3\") # 创建一个目录os.removedirs(\"new_dir\") # 删除一个目录 8.三元运算123# 1.result = 值1 if 条件 else 值2d=a if a&gt;b else cprint(d) 9.python3特性1234python3中最重要的新特性大概是对文本和二进制数据作了更为清晰的区分。文本总是Unicode，由str类型表示,二进制数据则由bytes类型表示。Python3不会以任意隐式的方式混用str和bytes，正是这使得两者区分特别清晰。即：在python2中类型会自动转化，而在python3中则要么报错，要么不转化str与bytes相互转化 10.bytes与str转化12345msg=\"我爱北京天安门\"print(msg)print(msg.encode(encoding=\"utf-8\")) # str转bytes,编码print(msg.encode(encoding=\"utf-8\").decode(encoding=\"utf-8\")) # bytes转str,解码 11.循环1234567891011121314151617181920212223242526272829303132print(\"第一种循环\")count = 0while True: print(\"count:\",count) count+=1 if(count==10): breakprint(\"第二种循环\")count = 0for count in range(0,10,2): print(\"count:\", count)for i in range(0,10): if i&lt;5: print(\"loop \",i) else: continue print(\"hehe....\")my_age=28count = 0while count&lt;3: user_input=int(input(\"input your guess num:\")) if user_input==my_age: print(\"Congratulations,you got it!\") break elif user_input&lt;my_age: print(\"Oops,think bigger!\") else: print(\"think smaller!\") count+=1 print(\"猜这么多次都不对，你个笨蛋.\") 12.练习—三级菜单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758data=&#123; '北京':&#123; \"昌平\":&#123; \"沙河\":[\"oldboys\",'test'], \"天通苑\":[\"链家地产\",\"我爱我家\"] &#125;, \"朝阳\":&#123; \"望京\":[\"oldboys\",'默陌陌'], \"国贸\":[\"CICC\",\"HP\"], \"东直门\":[\"Advent\",\"飞信\"] &#125;, \"海淀\":&#123;&#125; &#125;, '山东':&#123; \"德州\":&#123;&#125;, \"青岛\":&#123;&#125;, \"济南\":&#123;&#125; &#125;, '广东':&#123; \"德州\":&#123;&#125;, \"青岛\":&#123;&#125;, \"济南\":&#123;&#125; &#125;,&#125;exit_flag = Falsewhile not exit_flag: for i in data: print(i) choice=input(\"选择进入1&gt;&gt;:\") if choice in data: while not exit_flag: for i2 in data[choice]: print(\"\\t\",i2) choice2=input(\"选择进入2&gt;&gt;:\") if choice2 in data[choice]: while not exit_flag: for i3 in data[choice][choice2]: print(\"\\t\\t\", i3) choice3 = input(\"选择进入3&gt;&gt;:\") if choice3 in data[choice][choice2]: for i4 in data[choice][choice2][choice3]: print(i4) choice4=input(\"最后一层，按b返回&gt;&gt;:\") if choice4=='b': pass # pass可以理解为占位符，表示什么都不做，返回循环起始位置，以后可以在此处添加内容 elif choice4=='q': exit_flag=True if (choice3 == 'b'): break elif choice3 == 'q': exit_flag = True if (choice2 == 'b'): break elif choice2 == 'q': exit_flag = True if (choice == 'b'): break 二、Day21.编码变换12345# utf-8与gbk互相转化需要通过Unicode作为中介s=\"我爱北京天安门\" # 默认编码为Unicodeprint(s.encode(\"gbk\")) # Unicode可直接转化为gbkprint(s.encode(\"utf-8\")) # Unicode可直接转化为utf-8print(s.encode(\"utf-8\").decode(\"utf-8\").encode(\"gb2312\")) # 此时s.encode(\"utf-8\")即转为utf-8了，然后转为gb2312，则需要先告诉Unicode你原先的编码是什么，即s.encode(\"utf-8\").decode(\"utf-8\"),再对其进行编码为gb2312，即最终为s.encode(\"utf-8\").decode(\"utf-8\").encode(\"gb2312\") 2.文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394f=open('ly.txt','r',encoding='utf-8') # 文件句柄 'w'为创建文件，之前的数据就没了data=f.read()print(data)f.close()f=open('test','a',encoding='utf-8') # 文件句柄 'a'为追加文件 appendf.write(\"\\n阿斯达所，\\n天安门上太阳升\")f.close()f = open('ly.txt', 'r', encoding='utf-8') # 文件句柄for i in range(5):print(f.readline().strip()) # strip()去掉空格和回车for line in f.readlines(): print(line.strip())# 到第十行不打印for index,line in enumerate(f.readlines()): if index==9: print('----我是分隔符-----') continue print(line.strip())# 到第十行不打印count=0for line in f: if count==9: print('----我是分隔符-----') count += 1 continue print(line.strip()) count += 1f = open('ly.txt', 'r', encoding='utf-8') # 文件句柄print(f.tell())print(f.readline(5))print(f.tell())f.seek(0)print(f.readline(5))print(f.encoding)print(f.buffer)print(f.fileno())print(f.flush()) # 刷新缓冲区# 进度条import sys,timefor i in range(50): sys.stdout.write('#') sys.stdout.flush() time.sleep(0.5)f = open('ly.txt', 'a', encoding='utf-8') # 文件句柄f.seek(10)f.truncate(20) # 指定10到20个字符，10个字符前面留着，后面20字符清除f = open('ly.txt', 'r+', encoding='utf-8') # 文件句柄print(f.readline().strip())print(f.readline().strip())print(f.readline().strip())f.write(\"我爱中华\")f.close()# 实现简单的shell sed替换功能f=open(\"ly.txt\",\"r\",encoding=\"utf-8\")f_new=open(\"ly2.txt\",\"w\",encoding=\"utf-8\")for line in f: if \"肆意的快乐\" in line: line=line.replace(\"肆意的快乐\",\"肆意的happy\") f_new.write(line)f.close()f_new.close()import sysf=open(\"ly.txt\",\"r\",encoding=\"utf-8\")f_new=open(\"ly2.txt\",\"w\",encoding=\"utf-8\")find_str = sys.argv[1]replace_str = sys.argv[2]for line in f: if find_str in line: line=line.replace(find_str,replace_str) f_new.write(line)f.close()f_new.close()# with语句---为了避免打开文件后忘记关闭，可以通过管理上下文with open('ly.txt','r',encoding='utf-8') as f: for line in f: print(line.strip())# python2.7后，with又支持同时对多个文件的上下文进行管理，即:with open('ly.txt','r',encoding='utf-8') as f1,open('ly2.txt','r',encoding='utf-8'): pass 3.全局变量123456789101112names=[\"Alex\",\"Jack\",\"Rain\"]# 除了整数和字符串在函数内不能改，列表，字典这些可以改def change_name(): names[0]=\"金角大王\" print(\"inside func\",names )change_name()print(names)# 当全局变量与局部变量同名时，在定义局部变量的子程序内，局部变量起作用，在其它地方全局变量起作用。 4.list操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586__author__=\"Alex Li\"names=\"zhang Gu Xiang Xu\"names=[\"zhang\",\"Gu\",\"Xiang\",\"Xu\"]# 1.切片print(names[0],names[1],names[2])print(names[1:3]) # 顾头不顾尾，切片print(names[-1]) # 在不知道多长情况下，取最后一个位置print(names[-1:-3]) # 切片是从左往右，此时不输出print(names[-3:-1]) # 顾头顾尾，去最后三个print(names[-2:]) # 取最后两个print(names[0:3]) # 切片 等价于 print(names[:3])# 2.追加names.append(\"Lei\")print(names)# 3.指定位置插入names.insert(1,\"Chen\") # Gu前面插入print(names)# 4.修改names[2]=\"Xie\"print(names)# 5.删除# 第一种删除方法names.remove(\"Chen\")print(names)# 第二种删除方法del names[1]print(names)# 第三种删除方法names.pop() # 默认删除最后一个print(names)names.pop(1) #删除第二个元素print(names)print(names.index(\"Xu\")) # 1print(names[names.index(\"Xu\")]) #打印出找出的元素值3# 6.统计names.append(\"zhang\") #再加一个用于学习统计\"zhang\"的个数print(names.count(\"zhang\"))# 7.排序names.sort() #按照ASCII码排序print(names)names.reverse() # 逆序print(names)# 8.合并names2=[1,2,3,4]names.extend(names2)print(names,names2)# 9.删掉names2'''del names2'''print(names2) # NameError: name 'names2' is not defined,表示已删除# 10.浅copynames2=names.copy()print(names,names2) # 此时names2与names指向相同names[2]=\"大张\"print(names,names2) # 此时names改变，names2不变# 11.浅copy在列表嵌套应用names=[1,2,3,4,[\"zhang\",\"Gu\"],5]print(names)names2=names.copy()names[3]=\"斯\"names[4][0]=\"张改\"print(names,names2) # copy为浅copy,第一层copy不变，后面的嵌套全部都变,修改names2与names都一样# 12.完整克隆import copy# 浅copy与深copy'''浅copy与深copy区别就是浅copy只copy一层，而深copy就是完全克隆'''names=[1,2,3,4,[\"zhang\",\"Gu\"],5]# names2=copy.copy(names) # 这个跟列表的浅copy一样names2=copy.deepcopy(names) #深copynames[3]=\"斯\"names[4][0]=\"张改\"print(names,names2)# 13.列表循环for i in names: print(i)print(names[0:-1:2]) # 步长为2进行切片# 0与-1都可以省略掉print(names[::2]) # 步长为2进行切片# 浅拷贝三种方式person=['name',['a',100]]p1=copy.copy(person)p2=person[:] #其实p2=person[0:-1],0与-1均可以不写p3=list(person)print(p1,p2,p3) 5.Tuple操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 元组相当于只读列表,只有两个方法一个是count,一个是indexnames=('alex','jack','alex')print(names.count('alex'))print(names.index('jack'))# 购物篮程序product_list=[('Iphone', 5800), ('Mac Pro', 9800), ('Bike', 5800), ('Watch', 10600), ('Coffee', 31), ('Alex Python', 120),]shopping_list=[]salary=input(\"Input your salary:\")if salary.isdigit(): salary=int(salary) while True: '''for item in product_list: print(product_list.index(item),item) ''' for index,item in enumerate(product_list): print(index,item) user_choice=input(\"选择要买嘛？&gt;&gt;:\") if user_choice.isdigit(): user_choice=int(user_choice) if user_choice&lt;len(product_list) and user_choice&gt;=0: p_item=product_list[user_choice] if p_item[1]&lt;=salary: shopping_list.append(p_item) salary-=p_item[1] print(\"Added %s into shopping cart, your current balance is \\033[31;1m%s\\033[0m\"%(p_item,salary)) else: print(\"\\033[41;1m你的余额只剩[%s]啦，还买个毛线\\033[0m\"%salary) else: print(\"product code[%s] is not exist!\"%user_choice) elif user_choice=='q': print('-----------shopping list----------------') for p in shopping_list: print(p) print(\"Your current balance:\",salary) exit() else: print(\"invalid option\") 6.Set操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 集合set 集合关系测试list_1=[1,4,5,7,3,6,7,9]list_1=set(list_1)print(list_1,type(list_1))list_2=set([2,6,0,6,22,8,4])print(list_2,type(list_2))print(\"--------------------------------\")# 取交集print(\"方法一\")print(list_1.intersection(list_2))print(\"方法二\")print(list_1&amp;list_2)print(\"--------------------------------\")# 取并集print(\"方法一\")print(list_1.union(list_2))print(\"方法二\")print(list_1|list_2)print(\"--------------------------------\")# 差集 in list_1 but not in list_2print(list_1.difference(list_2))print(list_1-list_2)print(\"--------------------------------\")# 子集list_3=[1,4,6]list_4=[1,4,6,7]list_3=set(list_3)list_4=set(list_4)print(list_3.issubset(list_4))print(list_4.issuperset(list_3))print(\"--------------------------------\")# 对称差集 把list_1与list_2互相都没有的元素放在一块，其实就是去掉重复元素print(list_1.symmetric_difference(list_2))print(list_1^list_2)print(\"--------------------------------\")# 是否没有交集 Return True if two sets have a null intersection.list_5=set([1,2,3,4])list_6=set([5,6,7])print(list_5.isdisjoint(list_6))print(\"--------------------------------\")# 基本操作# 添加一项list_1.add('x')print(list_1)# 添加多项list_1.update([10,37,42])print(list_1)# 删除一项list_1.remove(10)print(list_1)# set长度print(len(list_1))# 测试9是否是list_1的成员print(9 in list_1)# pop()删除并且返回一个任意的元素print(list_1.pop())# 删除一个指定的值list_1.discard('x')print(list_1) 7.字符串操作1234567891011121314151617181920212223242526272829303132333435363738394041name=\"alex\"print(name.capitalize()) # 首字母大写print(name.count(\"a\")) # 统计字母个数print(name.count(\"a\")) # 统计字母个数print(name.center(50,\"-\")) #总共打印50个字符，并把nam放在中间，不够的用-补上print(name.endswith(\"ex\")) # 判断字符串以什么结尾name=\"alex \\tname is alex\"print(name.expandtabs(tabsize=30)) # 将name中\\t转为30个空格print(name.find(\"x\")) # 取索引print(name[name.find(\"x\"):]) # 字符串切片name=\"my \\tname is &#123;name&#125; and i am &#123;year&#125; old\"print(name.format(name=\"alex\",year=23))print(name.format_map(&#123;'name':'alex','year':23&#125;))print('ab123'.isalnum()) #isalnum()包含所有字母及数字，如果不是这两个，则为Falseprint('ab123'.isalpha()) # False isalpha()包含纯英文字符print('1A'.isdecimal()) # 是否是十进制 Falseprint('1A'.isdigit()) # 是否是整数 Falseprint('_'.isidentifier()) #判断是否是合法的标识符，实质是否为合法变量名 Trueprint('aasd'.islower()) # 判断是否是小写 Trueprint(''.isspace()) # 是否是空格 Falseprint('My name is'.istitle()) # 字符串首字母大写为title，否则不是print('+'.join(['1','2','3'])) # 对一列表中所有元素进行join操作print(name.ljust(50,'*')) # 左对齐字符串，多余位用*补全print(name.rjust(50,'-')) # 右对齐字符串，多余位用*-补全print('\\n Alex'.lstrip()) # 去掉左边的空格/回车print('\\nAlex\\n'.rstrip()) # 去掉右边的空格/回车print('\\nAlex\\n'.strip()) # 去掉左边和右边的空格/回车print('Alex')p=str.maketrans(\"abcdef\",\"123456\")print(\"alex li\".translate(p)) #把alex li换成上一行对应的值print(\"alex li\".replace('l','L',1)) # 替换 1表示替换几个l,从左到右计算替换个数print(\"alex li\".rfind('l')) # 找到的最右边的下标返回print(\"alex li\".split('l')) # 默认将字符串按照空格分隔成列表，也可以在()中填写相应的分隔符，比如以字符l分隔，print(\"alex li\".split(‘l’)),而且分隔符在列表中不会出现print(\"1+2+3+4\".split('+')) # ['1', '2', '3', '4']print(\"1+2\\n+3+4\".splitlines()) # ['1+2', '+3+4']print(\"Alex Li\".swapcase()) # aLEX lIprint('lex li'.title()) # Lex Liprint('lex li'.zfill(50)) #不够以0填充print('---') 8.字典1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# 字典无序info=&#123; 'stu1101':\"tengxun\", 'stu1102':\"baidu\", 'stu1103':\"ali\",&#125;print(info)# 0.查找# 方法一:确定存在print(info[\"stu1101\"]) # 查找若不在，则报错# 方法二:不确定存在，安全查找方法print(info.get(\"stu11004\")) # 查找不在不会报错，直接返回None，若有直接返回print('stu1103' in info) # True# 1.修改info[\"stu1101\"]=\"腾讯\"print(info)# 2.增加info[\"stu1104\"]=\"zhubajie\"print(info)# 3.删除# 方法一del info[\"stu1101\"]print(info)# 方法二info.pop(\"stu1102\")print(info)'''# 随机删除info.popitem()print(info)'''# 4.多级字典嵌套及操作av_catalog = &#123; \"欧美\":&#123; \"www.youporn.com\": [\"很多免费的,世界最大的\",\"质量一般\"], \"www.pornhub.com\": [\"很多免费的,也很大\",\"质量比yourporn高点\"], \"letmedothistoyou.com\": [\"多是自拍,高质量图片很多\",\"资源不多,更新慢\"], \"x-art.com\":[\"质量很高,真的很高\",\"全部收费,屌比请绕过\"] &#125;, \"日韩\":&#123; \"tokyo-hot\":[\"质量怎样不清楚,个人已经不喜欢日韩范了\",\"听说是收费的\"] &#125;, \"大陆\":&#123; \"1024\":[\"全部免费,真好,好人一生平安\",\"服务器在国外,慢\"] &#125;&#125;b=&#123; 'stu1101':\"Alex\", 1:3, 2:5&#125;info.update(b) #将两个字典合并，存在key,则更新value，不存在key，则合并print(info)print(info.items()) #把一个字典转成列表c=info.fromkeys([6,7,8],\"test\")print(c)c=info.fromkeys([6,7,8],[1,&#123;'name':'alex'&#125;,444])print(c)c[7][1]['name']='Jack Chen' # 3个key共用一个value,修改一个则所有的都修改了print(c)print(\"--------\")av_catalog[\"大陆\"][\"1024\"][1]=\"可以在国内做镜像\" # 二级字典替换av_catalog.setdefault(\"taiwan\",&#123;\"www.baidu.com\":[1,2]&#125;) # 如果不重名，即创建一个新的值，如果重名，将找到的值返回print(av_catalog)print(info.keys()) # 打印出所有的keyprint(info.values()) # 打印出所有的valueprint(\"---------------\")for i in info: print(i,info[i]) #效率更高点print(\"---------------\")for k,v in info.items(): print(k,v) 9.函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115# 1.无参函数# 定义一个函数def fun1(): '''testing''' print('in the fun1') return 1# 定义一个过程 实质就是无返回值的函数def fun2(): '''testing2''' print('in the fun2')x=fun1()y=fun2()print(x)print(y) # 没有返回值得情况下，python隐式地返回一个Noneimport timedef logger(): time_format='%Y-%m-%d %X %A %B %p %I' time_current=time.strftime(time_format) with open('a.txt','a+')as f: f.write('time %s end action\\n'%time_current)def test1(): print('in the test1') logger()def test2(): print('in the test2') logger() return 0def test3(): print('in the test3') logger() return 1,&#123;5:\"sda\",6:\"zad\"&#125;,[1,2,3]x=test1()y=test2()z=test3()print(x) # Noneprint(y) # 0print(z) # (1, &#123;5: 'sda', 6: 'zad'&#125;, [1, 2, 3])'''总结： 返回值数=0:返回None 返回值数=1:返回object 返回值数&gt;1:返回tuple'''# 2.有参函数# 默认参数特点：调用函数的时候，默认参数非必须传递# 用途：1.默认安装值def test(x,y): print(x) print(y)test(1,2) # 位置参数调用 与形参意义对应test(y=1,x=2) # 关键字调用，与形参顺序无关test(3,y=2) # 如果既有关键字调用又有位置参数，前面一个一定是位置参数，一句话：关键参数一定不能写在位置参数前面'''比如加入一个参数z'''def test1(x,y,z): print(x) print(y) print(z)# 关键参数一定不能放在位置参数前面test1(3,4,z=6)test1(3,z=6,y=4)# 默认参数,def test(x,y,z=2): print(x) print(y) print(z)test(1,2)# 用*args传递多个参数，转换成元组的方式 *表示一个功能代号，表示接受的参数不固定，args可以随意起名def test(*args): print(args)test(1,3,4,5,5,6)test(*[1,3,4,5,5,6]) # args=tuple([1,2,3,4,5])def test(x,*args): print(x) print(args)test(1,2,3,4,5,6,7) # 1 (2,3,4,5,6,7)# 字典传值 **kwagrs:把N个关键字参数，转换成字典的方式def test(**kwargs): print(kwargs) print(kwargs['name'],kwargs['age'],kwargs['id'],kwargs['sex'])test(name='alex',age=8,id=10,sex='M') # &#123;'name': 'alex', 'age': 8, 'id': 10, 'sex': 'M'&#125;test(**&#123;'name':'alex','age':8,'id':10,'sex':'M'&#125;)def test(name,**kwargs): print(name) print(kwargs)test('alex',age=18,sex='M') # 字典 &#123;'age': 18, 'sex': 'M'&#125;# 默认参数得放在参数组前面def test(name,age=18,**kwargs): print(name) print(age) print(kwargs)test('alex',sex='M',hobby='tesla',age=3)test('alex',3,sex='M',hobby='tesla')test('alex') # 后面的**kwargs不赋值输出为空字典def test(name,age=18,*args,**kwargs): print(name) print(age) print(args) print(kwargs)test('alex',age=34,sex='M',hobby='tesla') # alex 34 () &#123;'sex': 'M', 'hobby': 'tesla'&#125; 10.高阶函数1234567# 高阶函数 变量可以指向函数，函数的参数能接受变量，那么一个函数就可以接受另一个函数作为参数，这个函数就叫做高阶函数def f(x): return xdef add(x,y,f): return f(x)+f(y)res=add(1,2,f)print(res) # 3","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://guanhonly.github.io/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://guanhonly.github.io/tags/机器学习/"}]},{"title":"HBase原理探究（1）","slug":"hbase-construction1","date":"2018-12-01T12:21:12.000Z","updated":"2018-12-02T05:58:01.586Z","comments":true,"path":"2018/12/01/hbase-construction1/","link":"","permalink":"http://guanhonly.github.io/2018/12/01/hbase-construction1/","excerpt":"","text":"1. HBase的行、列和列族HBase的最基本的单位是列(column)，一列或多列形成一行(row)，并由唯一的行键(rowkey)来确定存储，rowkey按照字典排序。 一个表(table)中有若干行，其中每列可能有多个版本，这些不同的版本按照时间戳(timestamp)区分。 若干个列构成一个列族(column family)，一个列族中的所有列存储在一个HFile中。列族在创建表时就定义好，不能频繁修改，数量不能太多，而一个列族中的列可以有数百万，列值也没有类型和长度的规定。 列中的值允许为空，有利于存储十分稀疏的数据（这也是与传统关系型数据库相比一个很大的优势）。 关系型数据库和HBase的行列关系如下图： 取某个特定的值可以用table, rowkey, family, column, timestamp。其中timestamp由系统默认指定，也可以由用户使用。读取时优先读取新值。 2. 负载均衡HBase中扩展和负载均衡的基本单元称为region。region为按照行键排列的区间，如果region太大，系统会将他们动态地拆分，相反就会合并多个region。 一张表初始时只有一个region，当用户开始向表中插入数据时，系统会检查这个region大小，如果超过阈值，则会在中间键处将这些region分割开来，拆分成两个大致相等的region。 每一个region只能由一台region server加载，有一个region server可以同时加载多个region。其中region在region server中的分布为分散分布(如下图)。 每个region由多个store构成，一个store保存着一个column family。每个store由一个memStore和0个或多个storefile组成，storefile以HFile的形式存储在hdfs中。memstore用于在内存中缓存一定大小的数据，达到一定大小后批量写入HFile(flush)，数据是有序的。","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"HBase","slug":"HBase","permalink":"http://guanhonly.github.io/tags/HBase/"}]},{"title":"基于hexo的marble模板","slug":"howInstall","date":"2018-12-01T11:36:39.000Z","updated":"2019-03-30T13:07:01.010Z","comments":true,"path":"2018/12/01/howInstall/","link":"","permalink":"http://guanhonly.github.io/2018/12/01/howInstall/","excerpt":"","text":"我的旧版博客使用的模板。项目github地址：hexo-theme-marble 自己动手做的一个github个人主页，由于之前没有做过前端，所以在@ppoffice的Alex项目基础上改的。主要是根据我的个人喜好进行的界面的调整，并增加了评论功能。评论功能采用的gitalk。 整个界面追求极致简洁，黑白配色，所以取名marble。 安装方法：1. nodejs和hexo的安装可以参考这篇博客：用Hexo + github搭建自己的博客 — 再也不用羡慕别人了！ 2. 在你新建的hexo目录下，安装这个主题：1git clone https://github.com/guanhonly/hexo-theme-marble themes/marble marble要求Hexo 2.4及以上版本 3. 更改clone后的marble中的_config.yml，相关参数可见Alex的文档4. gitalk相关配置 首先，去这里申请github的授权，获得client ID和client Secret。 然后，修改 _config.yml中的相关配置：12345678gitalk: enable: true language: # 指定语言，默认从系统中获取 owner: # 申请时的owner admin: # 管理员，如果没有其他人，填自己 github_repo: # 用与保存评论的仓库名，建议填个人主页对应的仓库 client_id: # 刚刚生成的client ID client_secret: # 刚刚生成的client Secret 5. 在个人主页的根目录下，运行1hexo clean 然后运行1hexo g 最后运行1hexo d 过一会儿就可以上看到使用了这个模板的个人主页了 效果： 6.发布新博客在项目根目录下，输入：1hexo new \"PostName\" PostName即为你的这篇博客名称，创建成功的博客文件会在./source/_post中 文章编辑完成后，执行以下命令： 123hexo g //生成静态页面hexo s //在本地预览生成的页面，如果有信息可以不进行这一步hexo d //发布","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"实用教程","slug":"实用教程","permalink":"http://guanhonly.github.io/tags/实用教程/"}]},{"title":"关于我","slug":"aboutme","date":"2016-12-31T16:00:00.000Z","updated":"2019-09-21T14:26:46.541Z","comments":false,"path":"2017/01/01/aboutme/","link":"","permalink":"http://guanhonly.github.io/2017/01/01/aboutme/","excerpt":"","text":"Grab（中国）软件工程师。分享技术，分享阅读，分享生活。 欢迎来稿，无论是技术还是你擅长的领域，但必须是markdown格式。如果有离线图片请一并发送，并标明图片在文中的位置。邮箱地址：guanhonly@gmail.com markdown的基本语法可以参考：markdown基本语法","categories":[],"tags":[]}]}