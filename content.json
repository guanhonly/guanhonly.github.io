{"meta":{"title":"Honly's Blog","subtitle":"Stay hungry. Stay foolish.","description":null,"author":"Honly","url":"http://guanhonly.github.io"},"pages":[],"posts":[{"title":"Go语言slice前置插入（prepend）的坑","slug":"golang-prepend","date":"2020-08-10T15:22:56.000Z","updated":"2020-08-12T13:30:43.248Z","comments":true,"path":"2020/08/10/golang-prepend/","link":"","permalink":"http://guanhonly.github.io/2020/08/10/golang-prepend/","excerpt":"","text":"最近在工作中遇到一个需求，抽象为数据结构的问题就是：对于一个只记录了前向节点的链表，把其中所有节点的值转化为一个数组，数组需要保持原链表中各个值的顺序。也就是一个链表节点的数据结构长这样： 1234type ListNode struct &#123; Val int Prev *ListNode&#125; 需要向前遍历这个链表，用一个slice记录其每个节点的值，并且保持值在链表中的相对位置。咋一看这个需求很简单，只需要向前遍历链表，然后不断地往slice的最前面插入链表节点的值就行。于是写出了这样的代码： 1234567var res []intcurrNode := head // Type of head is *ListNodefor head != nil &#123; // Prepend res = append([]int&#123;head.Val&#125;, res...) currNode = currNode.Prev&#125; 相信很多人都会这么写，这样写也没有逻辑上的问题，并且很多算法题的题解都是这么写的。还有一些博主将这样的前置插入美名曰prepend，写一些博客教导新手这么写。先开始我也是这么写的（主要还是因为前人的代码里存在类似的操作），于是写几个ut过了之后，找别人review，reviewer也觉得可以，于是代码就心安理得地提交了。等到代码部署的时候，突然发现latency暴增，于是紧急回滚代码看问题。最终高latency的来源锁定在上面的代码，想了一下，高latency只可能来源于prepend操作（关于append的原理，可以看我之前的一篇博客：Go的奇特之处2–Go语言的slice）。在这种prepend操作中，每次append都会申请新地址空间，这是非常耗时的，如果链表长度很长（在这个需求中链表的长度可以达到上千），那么若干次申请新地址空间，就会造成高latency。找到原因，便开始着手该代码，由于这个需求能知道链表的最大可能长度，改起来比较简单：从一开始为slice申请足够的空间，然后将数值从后向前填入到slice中，最后截取slice即可： 12345678910// length is the longest possible length of list.res := make([]int, length)iter := length-1currNode := head // Type of head is *ListNodefor head != nil &#123; res[iter] = head.Val head = head.Prev iter--&#125;res = res[iter+1:] 如果实现无法知道链表的最大可能长度，可以先设置一个较大值，每次填充slice前先检查一下iter是否大于等于0，如果不是则对slice进行扩容再操作。修改完代码，和之前的方法进行本地测试对比，发现latency竟然能够下降两个数量级（latency单位为毫秒）。不得不感叹申请新地址空间是一个多么耗时的操作，以后写代码需要多多注意。","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://guanhonly.github.io/tags/Go语言/"}]},{"title":"如何设计一个分布式限流器（distributed rate limiter）","slug":"distributed-rate-limiter","date":"2020-05-30T15:44:23.000Z","updated":"2020-05-31T14:32:32.659Z","comments":true,"path":"2020/05/30/distributed-rate-limiter/","link":"","permalink":"http://guanhonly.github.io/2020/05/30/distributed-rate-limiter/","excerpt":"","text":"Rate Limiter限流器（rate limiter）是一种在实际工程中广泛应用的组件，其主要作用就是限制上游服务的请求量。比如一个公司有两个服务：服务A和服务B，服务A需要经常请求服务B，那么服务B为了保证自己不被来自A的异常高的请求打挂（即是现在分布式系统时代做自动扩容很快，但对于TPS较大的服务来说这些异常高的请求量仍然是有显著影响的），就会和服务A协商，定一个服务A的TPS阈值，设置限流器来保证自己服务的安全。又比如某公司G提供某种有偿的API服务，G公司为了赚钱需要对不同级别的TPS定不同的收费标准，那么G公司就必须要对这个API做流量控制，如果用户的TPS超过了某个阈值，那就返回错误，要想访问这个API更频繁并且获得正确的结果就得多交钱。很多提供API服务的公司都有自己的限流器，比如著名的同性交友网GitHub: GitHub REST API v3，明确了普通用户对API的请求必须在5000次/小时以内，否则就会返回403 Forbidden。类似的，领英也有自己的rate limiter，对不同的API有不同的限流准则：LinkedIn Getting started with the REST API。 限流算法（rate limiting algorithm）限流算法有很多，各有优劣，在这里简单介绍一下各种限流算法的差异。 漏桶法（Leaky Bucket）和令牌桶法（Token Bucket）其实我感觉两种算法虽然都带桶字，但两者的思路却完全不同。漏桶法比较直观，想象一个底部有个洞的桶，向桶口灌水，水通过底部的洞漏出来。桶底的洞一般是比桶口小很多的，所以如果灌水太快了桶就会被灌满，这样水就会溢出。灌水相当于上游打来请求，底部洞中漏水相当于处理请求，桶的大小即服务能够承受的流量，溢出的水就是被拒绝处理的请求。用数据结构抽象，漏桶就是一个FIFO的队列，请求不断地从队尾插入，服务不断地从队首取出请求进行处理，队列的容量就是服务能够承受的流量。漏桶法的好处很明显，服务完全不会被异常高的TPS打垮，并且原理很简单，比较容易实现。但如果有个请求处理时间较长，那么他后面的请求都会跟着遭殃，所以漏桶法会有一个请求阻塞其他请求的可能。并且如果上游打来的请求不均匀，则漏桶很容易被灌满，所以漏桶法也处理不了burst。令牌桶是想象有一个桶里放满了令牌，每来一个请求就取一个令牌，如果没有令牌可取了就拒绝处理请求，同时也会以一定的速率往桶里加令牌。一般往桶里加令牌的速率就被配置为平均的TPS，桶的容量则为能够接受的最大burst。令牌桶相比漏桶就有一个比较大的好处，那就是能够处理请求量的burst，能够处理上游不均匀的请求。 固定窗口法（Fixed Window）这里所说的窗口（window）就是时间窗口。固定窗口法规定了在某个固定的时间范围内的请求量阈值，如果在这个时间范围内的请求量超过阈值，则直接拒绝处理。固定窗口法的好处就是旧请求不会影响后面的新请求，但缺点也很明显，在窗口刷新的时候可能会放更多请求进来，比如配置的QPS是100，在上一个窗口的最后0.5秒打来了100个请求，在当前窗口的第一个0.5秒打来了100个请求，这样会在一秒内接受200个请求，与配置相去甚远。 滑动日志法（Sliding Log）滑动日志以日志的形式记录每个请求，每条日志包含一个请求的时间戳，如果有新请求，则根据其时间戳和之前的日志，计算TPS，如果TPS超过阈值则，则只加到日志不作处理。滑动日志法更像是无限容量的漏桶法，解决了固定窗口法的edge case，但需要存储日志，对存储来说有压力，并且每次来请求都要计算一次日志量，计算成本太高。 滑动窗口法（Sliding Window）滑动窗口法和固定窗口法很相似，区别就是固定窗口法每个时间窗口只能处理固定的请求量，而滑动窗口根据请求的时间往前找一个时间窗口，查看这个时间窗口的请求量是否超过了阈值，如果没有超过则处理请求，否则拒绝处理该请求。 滑动窗口法咋看起来很漏桶法很类似，但漏桶法新请求可能会被旧请求阻塞住，滑动窗口法就不会，并且滑动窗口的原理也比较简单易懂。滑动窗口也能处理请求量的burst，比如我们设置了时间窗口为一小时，有可能在上一个小时请求量还没超过阈值，则相当于可以将上一个小时剩余的容量加到当前这个小时，当前小时就能够处理更多的请求。 以上的方法都是对于单机而言的，关于单机版的限流器，比较著名的基本上都是基于令牌桶实现的，比如Google的Guava，Go语言的官方库中也有rate。 分布式限流器（distributed rate limiter）可以看到，以上的算法中，令牌桶（Token Bucket）和滑动窗口（Sliding Window）是两种最优的算法，都能够处理不均匀的请求。以上描述的算法都只是理论，在单机或许能够有效，但如今各个服务基本上都是分布式的，如何设计分布式限流器呢。 配置在负载均衡器（Load Balancer）首先最容易想到的是，在服务的负载均衡器（Load Balancer）中配置一个限流器，这样每来一个请求就可以进行一次检查，并且配置绝对是全局性的。这样做确实可以做到丝毫不差。但由于负载均衡器一般是云服务商提供的，一般的程序员可能无法直接在上面写代码。并且配置在负载均衡器上也做不了容错，可能还会影响扩容。 配置在中心化数据库由于我们想要一个全局的限流器，也就是说服务虽然部署在分布式系统中，但在外界看起来就像部署在单台机器上一样，那样就必须要一个中心化的存储设备去管理限流器，比如Redis。一种直观的做法是，将限流器配置在数据库中，每个节点收到来自上游的请求后直接请求数据库，然后数据库根据限流器判断是否处理这个请求，最后返回给节点相关信息。如果用Redis实现，限流器的代码可以通过Lua脚本的方式放在Redis端，从而减少节点访问Redis的次数。如果服务的流量不大的话，这种简单的基于中心化数据库的实现方法还能撑住。但如果服务的流量很大，这种方法则会有很大的成本和性能问题，每有一个上游的请求，节点就会请求一次数据库并等待数据库是否限流的回复，那么数据库的压力的特别大，会造成从数据库返回结果的延迟较高。并且为了得到正确的结果，每个节点访问数据库的时候还需要避免数据竞争，如果是支持事物的数据库还好，如果基于Redis做，这就需要对限流器加锁，Redis的延迟会更高，这样会导致服务处理请求的延迟很高。 优化基于中心化数据库的限流器为了解决因为对中心化数据库访问过于频繁并且需要加锁导致的延迟问题，做分布式限流器就必须要减少节点访问Redis的频次。这里我们就可以在节点上做一部分限流器的工作，再周期性地访问数据库同步，以达到减少对数据库请求的目的。以下称中心化数据库上的限流器为中心限流器，每个节点上的限流器为本地限流器。第一种方法是在节点上积攒够一定的请求量N后再去请求中心限流器，这样节点对中心化数据库的请求频次会降低为1/N。但在请求积攒阶段这些请求就无法决定是否被处理，这样也会造成一定的延迟增加。并且如果请求十分不均匀，在积攒阶段迟迟攒不到N个，即使设置了积攒超时也会大大增加延迟。同时，由于是一次性发送N个请求，也会造成一定的误差。第二种方法是认为负载均衡器会将流量十分均匀的分布在各个节点上，这样本地限流器的配置就等于全局限流器的配置除以节点数量。这样不需要中心限流器，只需要用一个中心化的数据库比如etcd/Redis存储节点的数量，每个节点以固定的频率请求节点数量更新本地的配置即可。每个节点可以定时向中心化数据库发送心跳，以便中心化数据库可以统计出活着的节点数。这样做对中心化数据库的压力更小，但误差也更大。首先负载均衡器并不能保证流量会十分均匀地打到各个节点上，其次中心化数据库也可能对活着的节点数量统计不准确，因为有可能节点在两次发送心跳图中就挂了。但个人觉得这个误差会始终在容忍范围内。前两种方法对于令牌桶和滑动窗口都适用，还有一种针对于令牌桶的方法：每个节点初始时请求中心限流器N个令牌，当N个令牌都消耗完了再去数据库请求N个。这种方法和第一种方法比较类似，也会有误差，但相比之下延迟会有所降低。 以上三种方法都会有一定的误差，就目前搜集到的资料来看，笔者没有发现没有误差且成本和性能都能接收的分布式限流器设计。如果是像G公司那样要靠限流来精准定价收费，可能他们就算建分布式数据库做中心化限流器也要准确地计算出TPS。如果是公司内部两个服务之间搞搞，那以上三种方法皆可，个人比较倾向于第二种方法，因为第二种方法对中心化数据库的压力最小，逻辑也比较简单，这样实现成本最小，误差虽然是最大的但感觉也在可容忍范围内。 小结以上这些都是些原理性的东西，为什么我不写个示例代码？因为这玩意儿已经有很多开源项目都搞了，最著名的应该就是Hystrix，还有一个轻量级的resilience4j，还有个人开发者弄的SnowJena。","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://guanhonly.github.io/tags/算法/"},{"name":"工程","slug":"工程","permalink":"http://guanhonly.github.io/tags/工程/"}]},{"title":"Go的奇特之处2--Go语言的slice","slug":"strange-Go-2","date":"2019-12-07T14:21:20.000Z","updated":"2020-08-12T13:16:42.953Z","comments":true,"path":"2019/12/07/strange-Go-2/","link":"","permalink":"http://guanhonly.github.io/2019/12/07/strange-Go-2/","excerpt":"","text":"Go语言中的slice，你可以将它简单地看作一个动态数组。动态数组在很多语言中都有实现，比如C++中的vector&lt;&gt;，Java中的Array&lt;&gt;，Python中的[]。那为什么要说Go语言的slice奇怪？首先来回顾一下slice的基本知识： slice由三部分组成：首地址、长度len、容量cap 那么，根据slice的这些特性，slice有啥奇特的呢？首先，举个例子： 123456789func main() &#123; a := []int&#123;1, 2, 3&#125; process(a) fmt.Println(a)&#125;func process(a []int) &#123; a[0] = 100&#125; 对Go语言有些了解的人都知道，Go语言的slice传参虽然都是值传递，但是会把首地址也一起传过去，所以上面代码的输出结果是这样的： 1[100 2 3] 接下来，可以想想以下代码的输出是什么： 123456789func main() &#123; a := []int&#123;1, 2, 3&#125; process(a) fmt.Println(a)&#125;func process(a []int) &#123; a = append(a, 4)&#125; 可能对Go有些了解的程序员会想到：append操作时，如果cap不够，则会申请一个新地址，在process()中的a的地址已经变了，所以返回的是: 1[1 2 3] 结果不错，那再看一个例子： 12345678910func main() &#123; a := make([]int, 3, 4) a[0], a[1], a[2] = 1, 2, 3 process(a) fmt.Println(a)&#125;func process(a []int) &#123; a = append(a, 4)&#125; 按照上面的思路，如果cap够的话，append不会申请新地址，那么上面的代码会返回[1 2 3 4]，但很遗憾，以上代码的输出是这样的： 1[1 2 3] 虽然fmt.Println将数组a打印出来了，但是fmt.Println实际上打印的是在数组a长度范围内的元素。换句话说，并没有打印在len之外但在cap之内的元素。并且，这些元素也是不能够通过下标访问的，如果写a[3]会直接在编译时报错：panic: 数组越界。其实，4已经写到了数组a中，那既然不能通过下标访问，怎样才能访问到呢？这就是Go语言一个奇特之处，可以通过对slice进行切片操作访问到： 12345678910func main() &#123; a := make([]int, 3, 4) a[0], a[1], a[2] = 1, 2, 3 process(a) fmt.Println(\"a[3]: \", a[3:4][0])&#125;func process(a []int) &#123; a = append(a, 4)&#125; 以上代码的输出： 1a[3]: 4 当然，如果是不通过函数的方式对数组a进行append操作，a的len也会随着其实际长度做出改变，比如： 123456func main() &#123; a := make([]int, 3, 4) a[0], a[1], a[2] = 1, 2, 3 a = append(a, 4) fmt.Println(\"a: \", a, \", len:\", len(a), \", cap:\", cap(a))&#125; 输出就是预期的这样： 1a: [1 2 3 4] , len: 4 , cap: 4 这就是Go语言slice的一个十分奇特的地方，对于slice来说，除了长度len以外，还有容量cap，并且超出len并在cap内的元素不能通过下标的方式访问，只能通过对slice进行切片操作来访问。在上面的几个例子中，process函数接收到了数组a的首地址、长度len和容量cap，由于是值传递，process只能改变地址上的值，对于a的len和cap就无能为力了，所以会出现修改了a中超出len但在cap中的值的情况。 Go语言的slice还有一个神奇的地方在于其append方法。上文说过，往一个数组中append一个元素时，如果超出了其cap，则会生成一个新的slice。奇特的地方在于，新生成slice的cap会比其len大。举个例子： 12345a := []int&#123;1, 2, 3&#125;fmt.Printf(\"addressBefore: %p\\n\", a)a = append(a, 4)fmt.Printf(\"addressAfter: %p\\n\", a)fmt.Println(\"len: \", len(a), \", cap: \", cap(a)) 以上代码的输出为： 123addressBefore: 0xc0000123c0addressAfter: 0xc00000e3c0len: 4 , cap: 6 由于新生成slice的cap比len大，于是再往其中append一个新元素时，数组的首地址便不会变。这个特性很重要，因为在写递归的时候很容易忽略这个特性，造成结果出错，例如： 12345678910// path := []int&#123;&#125;func dfs(path, nums []int, res [][]int, start int) &#123; if len(path) &gt; 0 &#123; res = append(res, path) &#125; //...skipped for i:=start; i&lt;len(nums); i++ &#123; dfs(append(path, nums[i]), nums, res, i+1) &#125;&#125; 以上这段代码是典型的dfs代码，我之前为了不写回退过程，打算利用append生成新slice的特性，重新生成一个slice。感觉逻辑上没啥问题，结果却是错的。在了解了append的特性后就很容易知道原因：以上代码中的path可能在append时由于cap比len大，没有生成新的slice，造成结果错误。所以，用Go语言写dfs或者类似的递归调用的时候，要么事先声明足够的cap，然后老老实实地写回退： 123456789101112// path := make([]int, 0, size)func dfs(path, nums []int, res [][]int, start int) &#123; if len(path) &gt; 0 &#123; res = append(res, path) &#125; //...skipped for i:=start; i&lt;len(nums); i++ &#123; path = append(path, nums[i]) dfs(path, nums, res, i+1) path = path[:len(path)-1] &#125;&#125; 要么调用copy方法拷贝一份后，再加入到res中： 123456789101112// path := []int&#123;&#125;func dfs(path, nums []int, res [][]int, start int) &#123; if len(path) &gt; 0 &#123; tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) &#125; //...skipped for i:=start; i&lt;len(nums); i++ &#123; dfs(append(path, nums[i]), nums, res, i+1) &#125;&#125; 以上就是Go语言slice中一些比较奇特并且值得注意的地方，slice的设计初衷感觉就是为了让大家不要写诸如*[]int这样的代码（这种代码看到过很多），所以了解slice的特性，有利于我们日常优雅地搬砖。","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://guanhonly.github.io/tags/Go语言/"}]},{"title":"Go的奇特之处1--Go语言的作用域","slug":"strange-Go-1","date":"2019-11-30T15:09:45.000Z","updated":"2020-08-12T13:30:28.435Z","comments":true,"path":"2019/11/30/strange-Go-1/","link":"","permalink":"http://guanhonly.github.io/2019/11/30/strange-Go-1/","excerpt":"","text":"作用域是指一个变量或函数在代码中能够有效地使用这个名称的范围。这个概念可能是老生常谈，在所有语言中都有这个概念，但是Go语言的作用域比较奇特。为了行文方便，我把由一对花括号{ }框起来的区域叫做句法块（其实这是在Go语言圣经上看到的概念）。在一个句法块内定义的变量或函数在这个句法块外是不能被调用的，你可以在一个句法块外定义一个相同名称的变量或函数，但那不同于句法块内的变量和函数，相当于生成了另外一个同名的东西。举个例子，如果一个变量x被定义在了一个句法块中，并赋值为1，那么调用x的时候，只在其句法块范围内值为1，如果在其作用域外定义了另一个x，那这个外面的x就不是句法块内的x，其值也就不一定是1了。这些概念看起来可能有点别扭，举一个简单的示例： 123456789// ...以上省略若干代码a := 1flag := trueif flag &#123; a = 2 fmt.Println(\"inside: \", a)&#125;fmt.Println(\"outside: \", a)// ...以下省略若干代码 以上这段代码大家都知道，会输出： 12inside: 2outside: 2 但是，Go语言的神奇之处在于，他允许你在if的句法块里再定义一个同名变量a： 123456789// ...以上省略若干代码a := 1flag := trueif flag &#123; a := 2 fmt.Println(\"inside: \", a)&#125;fmt.Println(\"outside: \", a)// ...以下省略若干代码 以上这段代码能够编译成功并运行，输出结果是这样： 12inside: 2outside: 1 惊不惊喜，意不意外？Go语言的机制就是这样，允许在句法块内定义同名的变量或函数。再举几个更加奇特的例子： 12345678// ...以上省略若干代码a := []int&#123;1, 2, 3, 4, 5&#125;for _, a := range a &#123; a++ fmt.Println(\"inside a: \", a)&#125;fmt.Println(\"outside a: \", a)// ...以下省略若干代码 以上代码是可以编译并运行的。在了解了Go语言作用域的概念后，以上这段代码的输出就可以理解了： 123456inside a: 2inside a: 3inside a: 4inside a: 5inside a: 6outside a: [1 2 3 4 5] 还有可以定义和包级变量同名的变量： 1234567891011// ...以上省略若干代码var a = 1func main() &#123; a := 2 fmt.Println(\"main a: \", a) printA()&#125;func printA() &#123; fmt.Println(\"global a: \", a)&#125;// ...以下省略若干代码 输出为： 12main a: 2global a: 1 当然，以上的代码虽然说逻辑正确，但是代码风格不太好，建议大家不要学着这样做，否则可能会让你的同事review你的代码时一头雾水，影响日常搬砖效率。 看了这些例子后，除了感觉Go语言的作用域很奇特之外，能够对我们的日常搬砖工作造成什么影响呢？下面举两个工作中可能会遇到的相关问题。 Go语言奇特的作用域可能会造成Bug（从Go语言圣经上抄的一个例子）： 12345678var cwd stringfunc init() &#123; cwd, err := os.Getwd() // compile error: unused: cwd if err != nil &#123; log.Fatalf(\"os.Getwd failed: %v\", err) &#125;&#125; 以上这段代码的本意是获取当前路径并赋值给包级变量cwd，但是由于开发人员想偷懒写成这样。由于使用了快速赋值，在init()内又生成了一个跟包级变量同名的变量cwd，这样编译都通过不了，因为init()中的cwd未使用过。当然，现在的IDE比如GoLand都会在变量下标红色波浪线提示你这个变量没有被使用过，但多注意还是好的，万一哪一天你就到vim上写代码去了呢。那么，如何改进这段代码，以达到最初始的目的呢？很简单，不要用快速赋值，走传统语言先定义、后赋值的老路，事先定义一个变量err： 123456789var cwd stringfunc init() &#123; var err error cwd, err = os.Getwd() if err != nil &#123; log.Fatalf(\"os.Getwd failed: %v\", err) &#125;&#125; 这样的话，在init()内并没有新定义一个名为cwd的变量，而是对包级变量cwd进行了赋值。 那么，除了能够规避错误，理解了Go语言的作用域还能有啥用不？比尔盖茨曾经说过：”I choose a lazy person to do a hard job. Because a lazy person will find an easy way to do it.” Go语言奇特的作用域还可以用来偷懒，特别是对于懒得想新变量名并且懒得写注释的懒癌晚期患者来说，是一个特别实用的feature。比如Go语言饱受诟病的异常捕捉方式，返回的错误显式地写在了返回值里，那么根据Go语言奇特的作用域，这种写法也可以： 12345678910// ...以上省略若干代码value, err := getValue()if shouldRecord &#123; err := record() if err != nil &#123; log.Println(\"record failed: \", err) // err is the returned error of record() &#125;&#125;return value, err // err is the returned error of getValue()// ...以下省略若干代码 以上代码的目的是获取值并返回，中间有个记录的步骤，如果记录失败则打印在日志里。那么在Go语言中，就不必再为record定义一个新错误名，直接用err即可，因为在if的句法块中，err相当于一个重新申请的一个变量，跟外面的那个err不是一个东西。通过类似的方法，巧用Go语言的作用域，可以节省想新变量名的时间和精力，也不用让同事被一个新出现的变量名抓耳挠腮，也可以不用专门写注释，做到了轻松、高效地搬砖，并改善了与同事之间的关系，何乐而不为呢。 以上就是Go语言作用域的奇特之处以及程序员可以如何利用这个奇特之处的小技巧。希望可以对看到这篇博客的人有所帮助。最后打个小广告，由于我写Go语言也只有不到半年的时间，并且是完全由于工作需要。为了锻炼自己的搬砖能力，我开了一个GitHub的仓库用来刷leetcode，主要按题目类型分类来刷，烦请看到的各位star一波:https://github.com/guanhonly/leetcode-solutions-in-Go","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://guanhonly.github.io/tags/Go语言/"}]},{"title":"初探Uber H3原理","slug":"uber-h3-preliminary-research","date":"2019-10-27T03:05:13.000Z","updated":"2019-12-07T14:12:14.904Z","comments":true,"path":"2019/10/27/uber-h3-preliminary-research/","link":"","permalink":"http://guanhonly.github.io/2019/10/27/uber-h3-preliminary-research/","excerpt":"","text":"2018年初，Uber正式开源了他们自己的一种空间索引算法H3（H3项目地址：h3）。最近偶然得知了这个算法，于是Google了一下，发现Uber还是比较良心地在其官网上给出了很多算法原理的讲解：简略版：H3: Uber’s Hexagonal Hierarchical Spatial Index详细版：H3 introdutction。如果英文还不错的话，建议直接看官方的介绍，我这里只是大致翻译和解释了一点原理层面的东西。 六边形网格索引H3是一种基于网格的空间索引，但跟普通的矩形网格索引不同的是，他的每一个网格都是正六边形。为啥要选正六边形呢，因为在基于网格的空间索引中，使用的多边形的边数越多，则一个网格越近似圆形，做缓冲区查询、kNN查询什么的也就越方便。而做网格索引又要求空间能够被网格铺满，不能有缝隙。根据初中数学知识，我们知道一个多边形的内角和公式为：$$\\theta = (x - 2) * 180^\\circ$$ 其中，x为多边形的边数，$\\theta$为多边形的内角和。则一个正多边形的每个角的角度为 $\\frac{\\theta}{x}=\\frac{(x - 2) * 180^\\circ}{x}$，而如果需要多边形能够铺满空间，则在多边形的顶点相交处，设每个顶点有y个多边形相交，需要满足以下等式： $$\\frac{360^\\circ}{y} = \\frac{(x - 2) * 180^\\circ}{x}$$以上等式的求解过程我不再赘述，这个等式只有三组整数解：$$\\begin{cases}x=3&amp;\\y=6&amp;\\\\end{cases}\\begin{cases}x=4&amp;\\y=4&amp;\\\\end{cases}\\begin{cases}x=6&amp;\\y=3&amp;\\\\end{cases}$$因此，能够做网格空间索引的形状只有三角形、矩形和六边形，而六边形因为边数最多，最接近圆，所以理论上来说在某些场景下是最优的选择。Uber的技术博客上也给出了使用六边形做空间索引的优越性： 上图展示了三种网格到其相邻网格的距离，可以看到，只有六边形到其相邻六边形的距离都是相等的。所以，H3就使用六边形作为网格索引的基本单元，实现空间索引。 无变形的投影在GIS领域中，对空间填充曲线熟悉的同学应该知道，不论是GeoHash, Z2或者Hilbert，虽然看起来都是将空间按照经纬度分割成了一个个大小相等的网格，但实际上这些网格的实际面积并不相等。对于靠近极地的网格，虽然经纬度的间隔没变，但由于地球的曲率，这些网格的实际面积远小于靠近赤道的网格。这种实际面积不相等的网格索引可能会造成一个问题，那就是由于网格大小不一致导致网格内数据量不一致，造成热网格和冷网格，Uber认为这会大大降低空间查询效率（笔者按：其实时空数据本身分布就十分不均匀，网格对应的实际大小不一致倒不是一个很大的影响，个人感觉在这一点上Uber有点言过其实）。于是，H3干脆摒弃传统的地图投影，直接在地球上铺满六边形（如图2）。但是，理想很美好，现实却需要考虑如何实现。这么多六边形，到高层级的时候很难对齐进行一一编码，这么看来使用六边形铺满地球不太现实。那怎么办呢？一个办法就是对这些六边形进行分区管理。H3实现的方法是：将地球当作一个二十面体，这个二十面体的每一个面都是球面三角形，有12个顶点，称为球形二十面体（spherical icosahedron），在这个球形十二面体的每个面上都有相同排列方式的六边形。由于这个球形二十面体的12个顶点每一个都在地球上的水里，可以保证对于每个面做处理时不会遇到边界的edge case，因为Uber还没有轮船快艇业务，只需要保证在陆地上H3好使就行。这个球形二十面体的示意图见图3。再考虑到图2所示的六边形网格，在第0层，这个球形二十面体的每一个面长这样：这样一来，可以看到，在一个球面三角形的顶角处有个小三角形，这个小三角形就是H3的一种edge case：在二十面体的顶点处，有五个面交于这个顶点，每个面在这个顶点处都有一个小三角形，所以这些小三角形会形成一个五边形。也就是说，H3并不能保证每个空间单元都是六边形，在一些地方还是会存在五边形，但是这样做也不会造成很大影响，因为根据球形二十面体每个顶点都在水里的特性，这种五边形只会出现在水域周围，不会对Uber的打车和外卖业务造成很大的影响。根据这样的索引特性，H3规定在索引的第0层，每个面和图4一样，每个面上有5.5个六边形和$\\frac{3}{5}$个五边形，即第0层一共有110个六边形和12个五边形。H3将这110个六边形称为基网格（base cells）。H3最高可以到15层，也就是说H3有16个层级的空间索引粒度，在粒度最细的第15层中，平均每个网格的大小为0.9平方米，平均边长为0.509713米。在往下一层划分时，每个父网格对应7个子网格，父子网格之间的对应关系是这样的： 可以看到，父子网格之间并没有严密的对齐，父网格和其所对应的7个子网格之间会有一点差异，这种差异也导致了H3并不能表现出很好的层级关系。 编码方式对六边形索引，H3使用了一种IJK坐标系来确定六边形的位置。IJK坐标系长这样：当然，H3不会简单地使用这种坐标系来对所有六边形进行编码，因为在每一个层级六边形的排列方式都不太一样。总的来说，在所有层级中，六边形的排列方式只有两种类型，称为Class II和Class III。在这两种类型的排列方式中，IJK坐标系的三个轴的方向不太一样。对于这种在一个二十面体的面上，根据不同的六边形排列方式使用不同方向坐标轴的坐标系，H3称之为FaceIJK坐标系：那么对于一个面上所有层级的所有六边形，都使用FaceIJK坐标系编码，再加上面的唯一标识符可不可以？答案是可以，但没必要，因为如果这样做，H3编码会更加表示不了层级之间的关系。H3为了突出层级之间的关联性，使用了一种方法：每个六边形都包含其父六边形的坐标。这样只需要规定好每个网格的子网格坐标的计算方法，对于子网格，只需在父网格的坐标后面追加子网格的坐标即可。这样一来，只需关注一个网格的7个子网格如何计算坐标，所有层级的每个网格的坐标都可以递归得到，这7个网格坐标的计算方法见图7，为了表述方便，我称之为IJK七网格坐标系。那么还有12个五边形咋办？不好意思，那12个五边形随着层级划分仍然是12个，层级越高这些五边形越小，并且都在海里，影响不大，直接不管了！同时，H3还专门设置了一种叫做网格有向边（directed edges of grid cells）的东西（如图8），其目的是为了网格能够快速地找到其某个邻网格。这种网格有向边分为单向网格有向边和双向网格有向边，比如说，对于两个相邻网格A和B，其相交的边是E，如果E是一条由A-&gt;B的单向边，那么只能通过A快速找到邻居B，B不能快速找到邻居A；而如果E是一条双向边，那么A可以快速地找到B，B也可以快速地找到A。那么，说了这么多，终于要说到最关键的H3索引值了。H3的索引值最多占63个比特位，可以用一个长整型表示，其结构如下所示： 0-3位：索引模式。0表示无效，1表示普通的网格，2表示单向边，3表示双向边（我也不知道为啥要用4个比特位表示，明明表示4种模式两位就够了，可能是为了以后能够加模式吧）；4-6位：如果索引模式是0或1，则没用；如果是2或3，表示这条边是这个六边形的哪条边，取值范围1-6；7-10位：表示层级，取值范围0-15；11-17位：表示这个网格属于哪个基网格，取值范围0-121；18-21位：表示这个网格的第一代祖宗网格在IJK七网格坐标系下的坐标；n-n+2(n&lt;=61)位：同上，表示这个网格的第i代祖宗网格在IJK七网格坐标系下的坐标 可以看到，其实对于层级数比较小的网格，后面很多位是不需要的，如果全置为0则会浪费很多空间，所以H3索引值是可以压缩的。压缩算法在官方文档里没有讲，需要看代码才能知道了，这都是后话。 总结Uber提出的这个H3索引其实有很强的实用性，除了上述的基本原理外，H3还支持空间覆盖和各种查询功能。虽然Uber批判了一番传统的空间索引，但是个人感觉H3并不是在所有时空查询/空间查询场景下都适用，例如在空间范围矩形范围查询场景下，其效率可能不如GeoHash/Z2/S2/Hilbert。并且H3舍弃了一部分海上的区域，只适用于陆地上空间数据的索引，对于轮船轨迹之类的空间数据就不太适用了。并且Uber自己也说，H3现在用于市场的定量分析（H3 is used throughout Uber to support quantitative analysis of our marketplace），H3还有没有被Uber用到其他地方，也许只有Uber自己知道。原理讲解就到这里，H3的使用方法和源码还请移步文章开头给出的H3官方文档和项目地址。后续如果有时间我会再探究一下H3的源码学习一下:smile:。","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"http://guanhonly.github.io/tags/GIS/"},{"name":"算法","slug":"算法","permalink":"http://guanhonly.github.io/tags/算法/"},{"name":"空间索引","slug":"空间索引","permalink":"http://guanhonly.github.io/tags/空间索引/"},{"name":"Uber","slug":"Uber","permalink":"http://guanhonly.github.io/tags/Uber/"}]},{"title":"轨迹压缩算法(Polyline encoding algorithm)探究","slug":"PolylineEncoding","date":"2019-09-05T12:17:10.000Z","updated":"2019-12-07T14:19:58.800Z","comments":true,"path":"2019/09/05/PolylineEncoding/","link":"","permalink":"http://guanhonly.github.io/2019/09/05/PolylineEncoding/","excerpt":"","text":"前言文中的代码表达采用Java，如果不想看原理，可以直接跳到博客末尾，有我写的一个Java版的demo一般来说，轨迹是由若干个轨迹点组成的数组来表达的，每个轨迹点可以表达为 $p = (x, y, t, A)$。其中 $x, y$ 是其空间坐标（一般来说，空间坐标用经纬度表示，即$x$一般对应经度(longitude)，$y$一般对应纬度(latitude)），$t$是记录这个轨迹点的时间戳(Timestamp), $A$则是这个轨迹点的属性。如果只想保留一个轨迹点最基本的信息，则只需要保留其空间信息和时间信息，即可以将一个轨迹点表示为 $p = (x, y, t)$。在写代码时，一个轨迹点的类型可以定义如下： 12345class PointTs &#123; double lng; double lat; long timestamp;&#125; 而这样保存一个轨迹点，$x$和$y$一般使用double类型，$t$一般使用long类型，再加上至少3个字符的分隔符（分隔x,y,t和每个轨迹点），一个轨迹点就要占 Double.SIZE * 2 + Long.SIZE + Character.SIZE * 3 == 27 * Byte.SIZE, 也就是说保存一个轨迹点至少需要占27个字节。在如今轨迹数量越来越大的情况下，有必要使用轨迹压缩的算法来解决轨迹数据量过大的问题。在查阅了资料后，我在Google地图开发平台中看到了Google采用的轨迹数据压缩算法，名为Polyline encoding algorithm（需要科学上网），可以将若干个轨迹点编码成一串字符串，并且实现轨迹的压缩。这是一个有损的压缩算法，并且可以压缩有符号的数字。接下来我将从编码和解码两个方面解析这个算法，并给出示例代码。 编码Polyline encoding算法的核心思想是对一个浮点数进行压缩，比如说，有一个经度为：-179.9832104 对于这样的浮点型数字，首先需要做的是想办法去掉其小数点。所以，可以预设一个10的整数倍的值来与这个浮点数相乘，并取得整数。 在这里，我预设这个值为$10^5$，将这个经度乘以$10^5$，得到：-17998321 将上一步得到的整数转换成二进制，由于我们的值是负数，得到的是17998321的补码：11111110 11101101 01011110 00001111 将二进制数左移一位：11111101 11011010 10111100 00011110 如果原来的数是负数，则取反码：00000010 00100101 01000011 111000013、4两步的目的是为了区分正负数，这样做后，负数的最后一位都是1，正数的最后一位都是0 从右到左，每5位分为一组（一组称为一个chunk）：00001 00010 01010 10000 11111 00001这样可以舍弃高位的0，节约空间。 将这些分组顺序反转（reverse order）：00001 11111 10000 01010 00010 00001这样做的目的是在写代码时可以每次从低位取数据，更适合代码实现。因为一般而言，写代码读二进制时，读高位比较复杂，而读低位较简单（例如，读最后五位只需要 &amp;0x1F），读到最后几位后可以直接append到结果中，不用插入到结果的前端，效率更高。 除了最后一个chunk，其他chunk和0x20进行或操作：100001 111111 110000 101010 100010 000001这一步的目的是保证只有最后一个chunk是小于0x20的。起到了分隔的作用。 分别将每个二进制的chunk转化为十进制的数字：33 63 48 42 34 1 对每个数字都加上63：96 126 111 105 97 64由于ASCII码前63位中有很多不可显示的控制符（比如NULL、换行符之类的），并且第127个是删除符，所以这一步将数字范围控制在了64~126之间。 将数字转化成ASCII表中对应的字符： 1`~oia@ 综上，一个浮点数被编码成了一串字符串，并且自带分隔符。对于时间戳这样的长整型来说，不进行第1步也可以编码为一串字符串，那么，将经度、纬度和时间戳的编码拼接起来就能够组成一个轨迹点的编码，还不用额外的分隔符。其实如果单独对一个数字来说，这个方法的压缩率并不高，有时候还会得不偿失。比如上述的数字-179.9832104，使用这种方法压缩后成为5个字符，占5个字节。如果将直接乘以$10^5$，可以直接用有符号的整型表示，还只占4个字节呢！所以，这个算法还有一个思想就是：后一个值用其与前一个值的差值表示，由于差值比较小，所以在上述的第5步时可以将高位的零舍弃掉，节省空间。下面是Google地图开发平台中给出的例子（这个例子中没有带时间戳）： 可以看到，这个例子中除了第一个轨迹点存储时全量信息（完整的经纬度数据）之外，后面的轨迹点都是存储的相对于前一个轨迹点偏移量。 解码解码其实就比较简单了，相当于把编码步骤倒过来执行一遍。编码中的步骤4可以使得我们在解码时知道这个数字是正数还是负数，步骤7可以让我们知道数字的边界在哪，所以还是比较方便解码的，我在此就不再赘述解码过程了。 Talk is cheap, show me the code原理知道了之后，代码就比较简单了，贴一个我写的代码：SimpleTrajectoryCompressor","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"http://guanhonly.github.io/tags/GIS/"},{"name":"算法","slug":"算法","permalink":"http://guanhonly.github.io/tags/算法/"},{"name":"Google","slug":"Google","permalink":"http://guanhonly.github.io/tags/Google/"},{"name":"轨迹","slug":"轨迹","permalink":"http://guanhonly.github.io/tags/轨迹/"}]},{"title":"Ubuntu16.04+1080ti显卡驱动循环登录问题解决办法","slug":"nvidia-driver-error","date":"2019-04-20T14:35:42.000Z","updated":"2019-12-07T13:06:41.045Z","comments":true,"path":"2019/04/20/nvidia-driver-error/","link":"","permalink":"http://guanhonly.github.io/2019/04/20/nvidia-driver-error/","excerpt":"","text":"昨天发现Ubuntu在登录界面循环登录，百度之后说是显卡驱动问题，于是将显卡驱动卸了，可是之后却再也装不上，装上了之后又循环登录了。 机器情况是两块NVIDIA 1080Ti，Ubuntu16.04系统。为了解决这个问题，百度、Google搜了半天，发现了一个写的很好的帖子Ubuntu16.04+1080ti显卡驱动安装流程+循环登录问题，上面的所有方法试过之后并没有什么卵用，尝试在NVIDIA官网上下载驱动后手动安装，发现提示gcc版本不对，起初没有关注这个问题，最终实在是没有办法，安装了对应版本的gcc，然后就好了。。。 所以，如果在网上搜到的所有方法都没奏效的话，不妨试试我的这个方法： 卸载旧显卡驱动： 1sudo apt-get remove --purge nvidia* 卸载旧gcc: 1sudo apt-get remove gcc 安装新gcc: 1sudo apt-get install gcc 安装新驱动： 1sudo apt-get install nvidia-418 //我这里根据我的显卡型号下载的，对应驱动型号可以在英伟达官网查找 重启 然后就大功告成了。","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"实用教程","slug":"实用教程","permalink":"http://guanhonly.github.io/tags/实用教程/"}]},{"title":"Google s2 lib研究之空间覆盖","slug":"s2-approximate-polygon-by-cell","date":"2019-03-30T13:07:54.000Z","updated":"2019-10-27T05:51:57.180Z","comments":true,"path":"2019/03/30/s2-approximate-polygon-by-cell/","link":"","permalink":"http://guanhonly.github.io/2019/03/30/s2-approximate-polygon-by-cell/","excerpt":"","text":"本文适合于对Google s2有一定了解或对空间索引有一定了解的读者。 空间索引常用的方法是空间填充曲线，比如Hilbert, Geohash等，被用于许多查询场景中。Google也推出了自己的空间索引——Google s2，这个项目是一个开源项目，有兴趣的可以直接看Google s2 java版源码和官方文档。对Google s2的介绍可以看Google’s S2, geometry on the sphere, cells and Hilbert curve，中文的可以看高效的多维空间点索引算法 — Geohash 和 Google S2。关于Google s2的基本原理在此就不再赘述，本文主要讲s2中一个重要的算法——空间覆盖。 可能这个算法名称乍一看有点一头雾水，在这里截取一张官方文档中的图： 意思就是，使用若干个s2定义的空间单元去逼近一个任意形状的区域，这些空间单元可能大小不一，并且可以设置最大的空间单元、最小的空间单元和空间单元数量。 官方文档没有给出其原理，在看了Google s2的源码之后，终于对这个算法有了一个初步的了解。 在讲算法之前，先说几点重要的概念： 每个非最底层的空间单元（简称cell，下同）都有四个子cell，即在Google s2中空间索引是四叉树的形式； 每个cell都有其特定的id，id的命名方法请参考官方文档。 接下来开始说算法： 算法输入是一个空间区域region，cell的最小层级minLevel和最大层级maxLevel，返回cell的数量maxCells，返回结果是cell id的集合result。源代码中有一个十分重要的函数addCandidate，过程有点复杂，在之后讲。在此只描述maxCells大于等于4且层级粒度为1时（特定条件）的主体算法。 定义一个优先队列candidateQueue，用于存储cell。其中排序的依据按照cell的权重由大到小排列，cell的权重计算方法后面讲。 初始化candidateQueue：用四个cell完全覆盖region的最小外包圆，这四个cell是同一层级的刚好能覆盖region的四个cell，即如果cell的层级再高一层，就不能完全覆盖region。对这四个cell执行addCandidate函数。 弹出candidateQueue的队首元素candidate，如果candidate的层级小于最小层级 || candidate的与region相交的子cell的数量只有1个 || resul.size()+candidateQueue.size()+candidate的与region相交的孩子的数量 &lt;= maxCells，则对candidate的与region相交的所有子cell执行addCandidate函数；否则将该candidate的id插入到result中。 如果candidateQueue不为空且result中元素的数量小于maxCells，则返回步骤3；否则结束算法。 接下来讲一下重点：addCandidate函数 addCandidate函数的源码如下（在本文中，根据特定条件作了一点修改，以方便读者理解）： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Process a candidate by either adding it to the result list or expanding its * children and inserting it into the priority queue. Passing an argument of * NULL does nothing. */ private void addCandidate(Candidate candidate) &#123; if (candidate == null) &#123; return; &#125; if (candidate.isTerminal) &#123; result.add(candidate.cell.id()); return; &#125; // Expand one level at a time until we hit min_level_ to ensure that // we don't skip over it. int numLevels = (candidate.cell.level() &lt; minLevel) ? 1 : levelMod; int numTerminals = expandChildren(candidate, candidate.cell, numLevels); if (candidate.numChildren == 0) &#123; // Do nothing &#125; else if (numTerminals == 1 &lt;&lt; 2 &amp;&amp; candidate.cell.level() &gt;= minLevel) &#123; // Optimization: add the parent cell rather than all of its children. candidate.isTerminal = true; addCandidate(candidate); &#125; else &#123; // We negate the priority so that smaller absolute priorities are returned // first. The heuristic is designed to refine the largest cells first, // since those are where we have the largest potential gain. Among cells // at the same level, we prefer the cells with the smallest number of // intersecting children. Finally, we prefer cells that have the smallest // number of children that cannot be refined any further. int priority = -((((candidate.cell.level() &lt;&lt; 2 + candidate.numChildren) &lt;&lt; 2) + numTerminals); candidateQueue.add(new QueueEntry(priority, candidate)); &#125; &#125; 从代码中可以看到，如果candidate被标记了isTerminal，就可以直接加入到result中，cell被标记isTerminal的条件是： cell被region完全包含 cell再向下剖分后层级会超过maxLevel 其中expandChildren函数是获取一个cell有会被标记为isTerminal的子cell数量，这个数量被记为numTerminals。如果一个cell的所有子cell全被标记为isTerminal，则直接将这个cell加入到result中（这个是一个优化项（Optimization），再向下划分毫无意义，这样做减小了算法复杂度）；否则将这个cell加入到candidateQueue中，其中优先级的计算方法我至今没搞懂，有弄懂的欢迎评论，优先级的计算转换为数学公式如下：$$priority = -（(level \\times 4 + numChildren)\\times 4 + numTerminals）$$其中level表示这个cell的层级，numChildren表示这个cell的和region相交的子cell数量。candidateQueue按照这个优先级由高到低排列。 做一个总结：这个算法相当于先将初始的cell（保证能完全覆盖region的cell，一般为4个）压入candidateQueue中，然后不断地从candidateQueue中获取需要处理的cell。如果cell有需要处理的子cell则将其子cell加入队列，如果cell已不需要处理则直接插入到结果列表中。直到candidateQueue为空或者result中元素的数量达到预设的 以上就是我从Google s2的java版源码中看到的空间覆盖算法，在给出了的测试有如下效果： 后来翻到了有人给出了更详细的s2空间覆盖源码剖析，是Go语言的：Google S2 是如何解决空间覆盖最优解问题的?","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"http://guanhonly.github.io/tags/GIS/"},{"name":"算法","slug":"算法","permalink":"http://guanhonly.github.io/tags/算法/"},{"name":"Google","slug":"Google","permalink":"http://guanhonly.github.io/tags/Google/"},{"name":"空间索引","slug":"空间索引","permalink":"http://guanhonly.github.io/tags/空间索引/"}]},{"title":"XZ曲线探究","slug":"XZOdering","date":"2018-12-27T13:51:59.000Z","updated":"2019-12-07T15:04:15.423Z","comments":true,"path":"2018/12/27/XZOdering/","link":"","permalink":"http://guanhonly.github.io/2018/12/27/XZOdering/","excerpt":"","text":"最近在做时空数据库相关的项目，需要做一些空间索引的工作，于是研究了一番GeoMesa和GeoWave。发现他们专门为Polygon类型数据使用了一种叫做XZ曲线的索引。空间填充曲线对于一个GISer来说十分熟悉，但XZ曲线确实是之前闻所未闻。根据GeoMesa的介绍，找到了XZ曲线的论文。论文写得晦涩难懂，看了半天仍未完全看明白。于是又去看GeoWave中关于XZ曲线的源码，终于将XZ的基本原理大致搞懂了。 本文使用的名词解释：cell: 传统Z曲线的网格单元element: XZ曲线的网格单元level: 层级g: 最大分辨率，即最大层级object: 对象，即需要存储的要素对象quadrant sequences: 象限序列，即传统Z曲线的编码interval: 一个区间(查询时使用)interval set: 区间集合（查询时使用） 空间填充曲线首先说一下空间填充曲线。空间填充曲线是一种将高维空间映射到一维空间的方法,经典的空间填充曲线有Z曲线、Hilbert曲线等，现在Google S2也经常被使用。Z曲线最常见的应用就是GeoHash，Hilbert是现在理论上空间邻近性最好的空间填充线曲线。关于GeoHash和Google s2可以参考高效的多维空间点索引算法 — Geohash 和 Google S2，Hilbert可以参考Hilbert曲线介绍以及代码实现。 空间填充曲线将空间进行划分为一个个大小相等的网格，一般对一个网格称为一个cell。那么，决定网格划分的数量的参数便是层级level，level越大，对空间进行的划分越精细，即level越大，cell的大小越小，数量越多。 Z曲线Z曲线是空间填充曲线的一种。在Z曲线中，level 1将空间划分为四个cell，level 2则将level 1中的每个cell进行四等分，生成的cell的长宽是level1中cell的一半，即level 2中有16个格网。以此类推，在level n中，存在$(2^2)^n$个cell。 Z曲线更加直观地显示如图1。 XZ曲线是根据Z曲线衍生出来的，相当于优化版的Z曲线。论文中详细阐述了为什么Z曲线需要被优化，并且XZ曲线是怎么解决Z曲线中的一些不足的。首先说明一下论文中对传统Z曲线及其编码的定义： Z曲线的cell按照象限序列（quadrant sequences，本文沿用论文名词）进行编码，即传统的Z曲线编码（见图2）。 将数据空间归一化为经纬度范围均为1的正方形，即将整个需要编码的空间作为一个边长为1的正方形，并具有x轴和y轴。则level n中每个cell的边长为$0.5^n$。 那么，作者认为，Z曲线有个致命的缺陷： 如果有很小的要素恰好在数据空间的正中心，则象限序列会为空（如图3）。 XZ曲线鉴于以上描述的Z曲线缺点，XZ曲线在Z曲线的基础上进行了优化，XZ曲线具有以下特性： 基本的单元（论文中称为element，本文沿用论文名词）为传统Z曲线cell向右上边长扩大一倍，临近的element之间存在50%的重叠度(如图4)。 element的数量和cell的数量一致，即边界也向外延伸。 XZ曲线存储要素时不作冗余存储，即单个要素只存储于一个element中。 对于XZ曲线的一些性质和论文中给出的一些定理，本文不加证明地罗列出来，如果感兴趣可以去论文中查看证明过程。如果实在不想看这些，可以直接跳到XZ曲线的插入操作。 XZ曲线最大的一个特点就是将cell向右上扩大为element，关于element论文中有一个定义： 定义1 设一个element的左下角cell的quadrant sequences为$s$，$|s|$为其长度，则element的边长为${0.5}^{|s|-1}$。 由于一个对象（文中称为对象object，本文沿用论文名词）只存储在一个element中，则一个object最多只和一个cell的两条边相交。则具有以下定理： 定理1 设$\\lvert s\\rvert$为一个quadrant sequences $s$的长度，w为一个object的宽度，h为一个object的高度。则$\\lvert s\\rvert$的范围为： $$l_1 \\le \\lvert s\\rvert \\lt l_2，其中 \\ l_1 = \\lfloor log_{0.5}(max\\{w,h\\}) \\rfloor,\\ l_2 = l_1 + 2$$ 由于不作冗余存储，一个object直接存储于一个element中，相当于使用一个element去逼近object,造成的误差会比较大。在论文中也写出了误差指标和XZ曲线的误差。设object的实际面积为$S_{obj}$，使用一个element进行存储时element的实际面积为$S_{ele}$，则逼近误差为：$$ E_{rel} = \\frac{S_{ele}-S_{obj}}{S_{obj}} $$XZ曲线的最大逼近误差小于15。 设最大level为g，则对于一个level $l$的cell，其具有的level g后代数量为：$$ N_{cell}(l) = 4^{g-l} $$则可求出，对于一个level $l$的cell，其具有的所有level的后代数量，是为定理2： 定理2 对于一个quadrant sequences $s$所代表的cell（level为$l$），其具有的所有level的element后代数量（包括当前对应的element，最大level为g)为：$$ N_{ele} = \\frac{4^{g-l+1}-1}{3} $$ 接下来就是最重要的一条定义，是XZ曲线的编码，称为sequence code： 定义2 对于一个quadrant sequences $s = \\langle \\ q_0 \\ q_1 \\ … \\ q_i \\ … \\ q_{l-1} \\ \\rangle$，可以得到其对应的XZ曲线编码(论文中称为sequence code)为：$$ C(s) = \\sum_{0\\le i \\lt l} q_i \\cdot \\frac{4^{g-i}-1}{3}+1 $$ 论文中对XZ曲线编码推论出了两个定理： 定理3 对于quadrant sequences $s$所对应的XZ编码值$C(s)$，其大小代表了$s$的字典序位置，即：$$ s_1 \\lt_{lex} s_2 \\Longleftrightarrow C(s_1) \\lt C(s_2) $$ 定理4 从quadrant sequences映射到数值型编码的方法中，sequence code具有最好的临近性。即相近的两个quadrant sequences对应的sequence code值最相近。 XZ曲线的插入操作XZ曲线的插入操作实际上就是获取一个object对应的XZ曲线编码。在GIS领域里，一般为了方便对不规则形状进行管理，都会将object加上一个BoundingRectangle，可以想象成一个能够将这个object装下的最小矩形。这个矩形存储object的详细信息，需要做拓扑计算等操作的时候可以使用BoundingRectangle进行一个快速的预计算。首先，需要确定object应该所处的层级，以确保一个element中能装下这个object的BoundingRectangle。根据定理1，设：$$ l_1 = \\lfloor log_{0.5}(max\\{w,h\\})\\rfloor $$其中，$w$为BoundingRectangle的宽度，$h$为BoundingRectangle的高度，一个object所在的层级为$l_1$或$l_1+1$。设$x_l$为BoundingRectangle的横轴（x轴）的下界，$y_l$为object的纵轴（y轴）的下界。设$w_2 = {0.5}^{l_1+1}$。则可根据以下两个式子可判断object的层级$l$：$$ x_l + w \\le \\lfloor \\frac{x_l}{w_2} \\rfloor \\cdot w_2 + 2w_2 $$$$ y_l + h \\le \\lfloor \\frac{y_l}{w_2} \\rfloor \\cdot w_2 + 2w_2 $$注：这个不等式和论文上不一致，经过讨论发现应该是论文出错，此处公式使用的是GeoWave源码中的公式若以上两式同时成立，则object的层级$l = l_1 + 1$，否则$l = l_1$ 得到层级$l$后，通过对空间的不断四分，得到BoundingRectangle左下角点所在的第$l$层的Z曲线编码(quadrant sequences)，然后，根据定义2，就可以得到XZ曲线编码(sequence code)。 XZ曲线的查询操作XZ曲线查询得到的结果是一个区间集合（interval set，本文沿用论文名词），interval set中的一个interval代表一个element中所有后代element的集合，即interval表示的是sequence code范围。 关于XZ曲线的查询生成interval set，论文中表述得较少并且不明确，GeoWave源码也没有完全按照论文中的方法来实现。本着实事求是的原则，以下按照GeoWave源码的方法讲述XZ曲线查询操作。 查询的方法为：给定一个查询框，如果查询框和包含某个element，则将该element对应的interval（即其所有后代element）加入到interval set中；如果查询框与某个element相交，则将该element作为一个interval（这个interval中只有这个element对象）加入到interval set中，并将这个element分裂为其子element，再和查询框进行拓扑关系判断，直至interval set中的数量达到给定的阈值或分裂至最大层级。得到interval set后，将其中有交集的interval进行合并，生成最终的interval set。 查询的伪代码如下： 123456789101112131415161718192021222324252627282930313233343536Queue&lt;Element&gt; remaining; // 待处理队列List&lt;Interval&gt; intervalSet; // 最终结果remaining.add(LevelOneElement); // 加入第一层的elementremaining.add(LevelTerminator); // 加入一层的终止条件while (level &lt; g &amp;&amp; !remaining.empty() &amp;&amp; intervalSet.size() &lt; maxSize) &#123; Element next = remaining.poll(); if (next == LevelTerminator) &#123; if (!remaining.isEmpty()) &#123; level = level + 1; remaining.add(LevelTerminator); &#125; &#125; else &#123; if (query.contain(next)) &#123; intervalSet.add(interval(next)); &#125; else if (query.intersect(next)) &#123; intervalSet.add(next); remaining.add(next.children()); &#125; &#125;&#125;// 兜底策略，将未处理完的element处理完while (!remaining.empty()) &#123; Element next = remaining.poll(); if (next == LevelTerminator) &#123; level = level + 1; &#125; else &#123; intervalSet.add(interval(next)); &#125;&#125;mergeIntervalsWhichAreIntersected(intervalSet); 总结XZ曲线的论文在1999年就发表了，是一篇会议论文，但是基本上没什么名气，用的人也很少，目前来看除了GeoMesa/GeoWave用过外，就没有什么知名开源项目使用过了，所以现在能获取的相关信息很少（感觉有一个原因是论文写得太晦涩难懂了），只能通过原始的论文和GeoWave的代码来一步步搞清楚原理。论文作者在实验章节基于ORACLE-8做了一个实验（然而这个代码没公开），测试XZ曲线和传统Z曲线查询时磁盘页的访问数量，结果表明XZ曲线的磁盘页访问数量远小于Z曲线。然而我感觉虽然Z曲线会冗余存储，但是在查询速度上可能是要胜于XZ曲线的。最后，在好不容易看完这篇论文后，我们又调研了其他的分布式时空数据库，然而没有发现其他使用XZ曲线的，所以我也没有测试XZ曲线的性能。如果看到了这篇博客并且有兴趣的大佬，可以尝试把GeoWave的代码clone下来后跑一跑他们XZ曲线相关的代码（项目地址在博客第一段已经给出）。 Acknowledgement感谢同组的@Louis Liu和我一起看XZ曲线的论文和源码（他没有GitHub和微博账号，只能这么感谢了😂）","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"http://guanhonly.github.io/tags/GIS/"},{"name":"空间填充曲线","slug":"空间填充曲线","permalink":"http://guanhonly.github.io/tags/空间填充曲线/"}]},{"title":"（转载）Python基础","slug":"python-learn-1","date":"2018-12-03T10:35:12.000Z","updated":"2018-12-03T11:18:49.949Z","comments":true,"path":"2018/12/03/python-learn-1/","link":"","permalink":"http://guanhonly.github.io/2018/12/03/python-learn-1/","excerpt":"","text":"转载自：Python基础长文 一、Day10.print123name = input(\"What is your name?\")print(\"Hello \"+name )# 或者print(\"Hello\",name ),print中逗号分隔直接将字符串用空格分隔，若用+号连接，并且想留空格，则在前一字符串留空格即可 1.输入输出123username=input(\"username:\")password=input(\"password:\")print(username,password) 2.格式输入输出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 第一种方法name=input(\"Name:\")age=input(\"age:\")job=input(\"job:\")info='''---------info of ---------''' + '''Name:'''+name+'''Age:'''+age+'''Job:'''+jobprint(info)# 第二种方法name=input(\"Name:\")age=int(input(\"age:\")) #如果不用int()就会报错(虽然输入为数字，但是print(type(age))为str型)，因为python如果不强制类型转化，就会默认字符型job=input(\"job:\")info='''---------info of ---------Name:%sAge:%dJob:%s'''%(name,age,job)print(info)# 第三种方法name=input(\"Name:\")age=int(input(\"age:\")) #如果不用int()就会报错(虽然输入为数字，但是print(type(age))为str型)，因为python如果不强制类型转化，就会默认字符型job=input(\"job:\")info='''---------info of ---------Name:&#123;_name&#125;Age:&#123;_age&#125;Job:&#123;_job&#125;'''.format(_name=name,_age=age,_job=job)print(info)# 第四种方法name=input(\"Name:\")age=int(input(\"age:\")) #如果不用int()就会报错(虽然输入为数字，但是print(type(age))为str型)，因为python如果不强制类型转化，就会默认字符型job=input(\"job:\")info='''---------info of ---------Name:&#123;0&#125;Age:&#123;1&#125;Job:&#123;2&#125;'''.format(name,age,job)print(info) 3.输入密码不可见123import getpasspwd=getpass.getpass(\"请输入密码:\")print(pwd) 4.验证，python缩进12345678_username='Alex Li'_password='abc123'username=input(\"username:\")password=input(\"password:\")if _username==username and _password==password: print((\"Welcome user &#123;name&#125; login...\").format(name=username))else: print(\"Invalid username or password!\") 5.指向—修改字符串123456789print(\"Hello World\")name = \"Alex Li\"name2=nameprint(name)print(\"My name is\", name,name2) # Alex Li Alex Liname = \"PaoChe Ge\"# name2=name指的是name2与name一样指向Alex Li的内存地址，name指向改了，但是name2不变print(\"My name is\", name,name2) # PaoChe Ge Alex Liprint(\"您好，我来了\") 6.注释`‘’’ ‘’’`内涵123456789# 第一种情况就是注释'''print(\"这是一行注释\")'''#第二种情况就是打印多行字符串str='''这是第一行内容这是第二行内容'''print(str)# 3.单套双，双套单都可以str1=\"i'am a student\"print(str1) 7.模块初始sys与os123456789101112131415161718192021222324import sys# 打印环境变量print(sys.path)print(sys.argv)print(sys.argv[2])# 进度条import timefor i in range(50): sys.stdout.write('#') sys.stdout.flush() time.sleep(0.5)import oscmd_res = os.system(\"dir\") # os.system()执行后直接输出到终端，然后结束，最后cmd_res保存的是os.system()执行后的状态码print(\"---&gt;\",cmd_res) # ---&gt; 0cmd_res1=os.popen(\"dir\")print(\"---&gt;\",cmd_res1) # 得到的是内存对象值 ---&gt; &lt;os._wrap_close object at 0x00000000029187B8&gt;cmd_res1=os.popen(\"dir\").read()print(\"---&gt;\",cmd_res1) # 读取数据必须再后面加个read()os.mkdir(\"new_dir3\") # 创建一个目录os.removedirs(\"new_dir\") # 删除一个目录 8.三元运算123# 1.result = 值1 if 条件 else 值2d=a if a&gt;b else cprint(d) 9.python3特性1234python3中最重要的新特性大概是对文本和二进制数据作了更为清晰的区分。文本总是Unicode，由str类型表示,二进制数据则由bytes类型表示。Python3不会以任意隐式的方式混用str和bytes，正是这使得两者区分特别清晰。即：在python2中类型会自动转化，而在python3中则要么报错，要么不转化str与bytes相互转化 10.bytes与str转化12345msg=\"我爱北京天安门\"print(msg)print(msg.encode(encoding=\"utf-8\")) # str转bytes,编码print(msg.encode(encoding=\"utf-8\").decode(encoding=\"utf-8\")) # bytes转str,解码 11.循环1234567891011121314151617181920212223242526272829303132print(\"第一种循环\")count = 0while True: print(\"count:\",count) count+=1 if(count==10): breakprint(\"第二种循环\")count = 0for count in range(0,10,2): print(\"count:\", count)for i in range(0,10): if i&lt;5: print(\"loop \",i) else: continue print(\"hehe....\")my_age=28count = 0while count&lt;3: user_input=int(input(\"input your guess num:\")) if user_input==my_age: print(\"Congratulations,you got it!\") break elif user_input&lt;my_age: print(\"Oops,think bigger!\") else: print(\"think smaller!\") count+=1 print(\"猜这么多次都不对，你个笨蛋.\") 12.练习—三级菜单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758data=&#123; '北京':&#123; \"昌平\":&#123; \"沙河\":[\"oldboys\",'test'], \"天通苑\":[\"链家地产\",\"我爱我家\"] &#125;, \"朝阳\":&#123; \"望京\":[\"oldboys\",'默陌陌'], \"国贸\":[\"CICC\",\"HP\"], \"东直门\":[\"Advent\",\"飞信\"] &#125;, \"海淀\":&#123;&#125; &#125;, '山东':&#123; \"德州\":&#123;&#125;, \"青岛\":&#123;&#125;, \"济南\":&#123;&#125; &#125;, '广东':&#123; \"德州\":&#123;&#125;, \"青岛\":&#123;&#125;, \"济南\":&#123;&#125; &#125;,&#125;exit_flag = Falsewhile not exit_flag: for i in data: print(i) choice=input(\"选择进入1&gt;&gt;:\") if choice in data: while not exit_flag: for i2 in data[choice]: print(\"\\t\",i2) choice2=input(\"选择进入2&gt;&gt;:\") if choice2 in data[choice]: while not exit_flag: for i3 in data[choice][choice2]: print(\"\\t\\t\", i3) choice3 = input(\"选择进入3&gt;&gt;:\") if choice3 in data[choice][choice2]: for i4 in data[choice][choice2][choice3]: print(i4) choice4=input(\"最后一层，按b返回&gt;&gt;:\") if choice4=='b': pass # pass可以理解为占位符，表示什么都不做，返回循环起始位置，以后可以在此处添加内容 elif choice4=='q': exit_flag=True if (choice3 == 'b'): break elif choice3 == 'q': exit_flag = True if (choice2 == 'b'): break elif choice2 == 'q': exit_flag = True if (choice == 'b'): break 二、Day21.编码变换12345# utf-8与gbk互相转化需要通过Unicode作为中介s=\"我爱北京天安门\" # 默认编码为Unicodeprint(s.encode(\"gbk\")) # Unicode可直接转化为gbkprint(s.encode(\"utf-8\")) # Unicode可直接转化为utf-8print(s.encode(\"utf-8\").decode(\"utf-8\").encode(\"gb2312\")) # 此时s.encode(\"utf-8\")即转为utf-8了，然后转为gb2312，则需要先告诉Unicode你原先的编码是什么，即s.encode(\"utf-8\").decode(\"utf-8\"),再对其进行编码为gb2312，即最终为s.encode(\"utf-8\").decode(\"utf-8\").encode(\"gb2312\") 2.文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394f=open('ly.txt','r',encoding='utf-8') # 文件句柄 'w'为创建文件，之前的数据就没了data=f.read()print(data)f.close()f=open('test','a',encoding='utf-8') # 文件句柄 'a'为追加文件 appendf.write(\"\\n阿斯达所，\\n天安门上太阳升\")f.close()f = open('ly.txt', 'r', encoding='utf-8') # 文件句柄for i in range(5):print(f.readline().strip()) # strip()去掉空格和回车for line in f.readlines(): print(line.strip())# 到第十行不打印for index,line in enumerate(f.readlines()): if index==9: print('----我是分隔符-----') continue print(line.strip())# 到第十行不打印count=0for line in f: if count==9: print('----我是分隔符-----') count += 1 continue print(line.strip()) count += 1f = open('ly.txt', 'r', encoding='utf-8') # 文件句柄print(f.tell())print(f.readline(5))print(f.tell())f.seek(0)print(f.readline(5))print(f.encoding)print(f.buffer)print(f.fileno())print(f.flush()) # 刷新缓冲区# 进度条import sys,timefor i in range(50): sys.stdout.write('#') sys.stdout.flush() time.sleep(0.5)f = open('ly.txt', 'a', encoding='utf-8') # 文件句柄f.seek(10)f.truncate(20) # 指定10到20个字符，10个字符前面留着，后面20字符清除f = open('ly.txt', 'r+', encoding='utf-8') # 文件句柄print(f.readline().strip())print(f.readline().strip())print(f.readline().strip())f.write(\"我爱中华\")f.close()# 实现简单的shell sed替换功能f=open(\"ly.txt\",\"r\",encoding=\"utf-8\")f_new=open(\"ly2.txt\",\"w\",encoding=\"utf-8\")for line in f: if \"肆意的快乐\" in line: line=line.replace(\"肆意的快乐\",\"肆意的happy\") f_new.write(line)f.close()f_new.close()import sysf=open(\"ly.txt\",\"r\",encoding=\"utf-8\")f_new=open(\"ly2.txt\",\"w\",encoding=\"utf-8\")find_str = sys.argv[1]replace_str = sys.argv[2]for line in f: if find_str in line: line=line.replace(find_str,replace_str) f_new.write(line)f.close()f_new.close()# with语句---为了避免打开文件后忘记关闭，可以通过管理上下文with open('ly.txt','r',encoding='utf-8') as f: for line in f: print(line.strip())# python2.7后，with又支持同时对多个文件的上下文进行管理，即:with open('ly.txt','r',encoding='utf-8') as f1,open('ly2.txt','r',encoding='utf-8'): pass 3.全局变量123456789101112names=[\"Alex\",\"Jack\",\"Rain\"]# 除了整数和字符串在函数内不能改，列表，字典这些可以改def change_name(): names[0]=\"金角大王\" print(\"inside func\",names )change_name()print(names)# 当全局变量与局部变量同名时，在定义局部变量的子程序内，局部变量起作用，在其它地方全局变量起作用。 4.list操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586__author__=\"Alex Li\"names=\"zhang Gu Xiang Xu\"names=[\"zhang\",\"Gu\",\"Xiang\",\"Xu\"]# 1.切片print(names[0],names[1],names[2])print(names[1:3]) # 顾头不顾尾，切片print(names[-1]) # 在不知道多长情况下，取最后一个位置print(names[-1:-3]) # 切片是从左往右，此时不输出print(names[-3:-1]) # 顾头顾尾，去最后三个print(names[-2:]) # 取最后两个print(names[0:3]) # 切片 等价于 print(names[:3])# 2.追加names.append(\"Lei\")print(names)# 3.指定位置插入names.insert(1,\"Chen\") # Gu前面插入print(names)# 4.修改names[2]=\"Xie\"print(names)# 5.删除# 第一种删除方法names.remove(\"Chen\")print(names)# 第二种删除方法del names[1]print(names)# 第三种删除方法names.pop() # 默认删除最后一个print(names)names.pop(1) #删除第二个元素print(names)print(names.index(\"Xu\")) # 1print(names[names.index(\"Xu\")]) #打印出找出的元素值3# 6.统计names.append(\"zhang\") #再加一个用于学习统计\"zhang\"的个数print(names.count(\"zhang\"))# 7.排序names.sort() #按照ASCII码排序print(names)names.reverse() # 逆序print(names)# 8.合并names2=[1,2,3,4]names.extend(names2)print(names,names2)# 9.删掉names2'''del names2'''print(names2) # NameError: name 'names2' is not defined,表示已删除# 10.浅copynames2=names.copy()print(names,names2) # 此时names2与names指向相同names[2]=\"大张\"print(names,names2) # 此时names改变，names2不变# 11.浅copy在列表嵌套应用names=[1,2,3,4,[\"zhang\",\"Gu\"],5]print(names)names2=names.copy()names[3]=\"斯\"names[4][0]=\"张改\"print(names,names2) # copy为浅copy,第一层copy不变，后面的嵌套全部都变,修改names2与names都一样# 12.完整克隆import copy# 浅copy与深copy'''浅copy与深copy区别就是浅copy只copy一层，而深copy就是完全克隆'''names=[1,2,3,4,[\"zhang\",\"Gu\"],5]# names2=copy.copy(names) # 这个跟列表的浅copy一样names2=copy.deepcopy(names) #深copynames[3]=\"斯\"names[4][0]=\"张改\"print(names,names2)# 13.列表循环for i in names: print(i)print(names[0:-1:2]) # 步长为2进行切片# 0与-1都可以省略掉print(names[::2]) # 步长为2进行切片# 浅拷贝三种方式person=['name',['a',100]]p1=copy.copy(person)p2=person[:] #其实p2=person[0:-1],0与-1均可以不写p3=list(person)print(p1,p2,p3) 5.Tuple操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 元组相当于只读列表,只有两个方法一个是count,一个是indexnames=('alex','jack','alex')print(names.count('alex'))print(names.index('jack'))# 购物篮程序product_list=[('Iphone', 5800), ('Mac Pro', 9800), ('Bike', 5800), ('Watch', 10600), ('Coffee', 31), ('Alex Python', 120),]shopping_list=[]salary=input(\"Input your salary:\")if salary.isdigit(): salary=int(salary) while True: '''for item in product_list: print(product_list.index(item),item) ''' for index,item in enumerate(product_list): print(index,item) user_choice=input(\"选择要买嘛？&gt;&gt;:\") if user_choice.isdigit(): user_choice=int(user_choice) if user_choice&lt;len(product_list) and user_choice&gt;=0: p_item=product_list[user_choice] if p_item[1]&lt;=salary: shopping_list.append(p_item) salary-=p_item[1] print(\"Added %s into shopping cart, your current balance is \\033[31;1m%s\\033[0m\"%(p_item,salary)) else: print(\"\\033[41;1m你的余额只剩[%s]啦，还买个毛线\\033[0m\"%salary) else: print(\"product code[%s] is not exist!\"%user_choice) elif user_choice=='q': print('-----------shopping list----------------') for p in shopping_list: print(p) print(\"Your current balance:\",salary) exit() else: print(\"invalid option\") 6.Set操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 集合set 集合关系测试list_1=[1,4,5,7,3,6,7,9]list_1=set(list_1)print(list_1,type(list_1))list_2=set([2,6,0,6,22,8,4])print(list_2,type(list_2))print(\"--------------------------------\")# 取交集print(\"方法一\")print(list_1.intersection(list_2))print(\"方法二\")print(list_1&amp;list_2)print(\"--------------------------------\")# 取并集print(\"方法一\")print(list_1.union(list_2))print(\"方法二\")print(list_1|list_2)print(\"--------------------------------\")# 差集 in list_1 but not in list_2print(list_1.difference(list_2))print(list_1-list_2)print(\"--------------------------------\")# 子集list_3=[1,4,6]list_4=[1,4,6,7]list_3=set(list_3)list_4=set(list_4)print(list_3.issubset(list_4))print(list_4.issuperset(list_3))print(\"--------------------------------\")# 对称差集 把list_1与list_2互相都没有的元素放在一块，其实就是去掉重复元素print(list_1.symmetric_difference(list_2))print(list_1^list_2)print(\"--------------------------------\")# 是否没有交集 Return True if two sets have a null intersection.list_5=set([1,2,3,4])list_6=set([5,6,7])print(list_5.isdisjoint(list_6))print(\"--------------------------------\")# 基本操作# 添加一项list_1.add('x')print(list_1)# 添加多项list_1.update([10,37,42])print(list_1)# 删除一项list_1.remove(10)print(list_1)# set长度print(len(list_1))# 测试9是否是list_1的成员print(9 in list_1)# pop()删除并且返回一个任意的元素print(list_1.pop())# 删除一个指定的值list_1.discard('x')print(list_1) 7.字符串操作1234567891011121314151617181920212223242526272829303132333435363738394041name=\"alex\"print(name.capitalize()) # 首字母大写print(name.count(\"a\")) # 统计字母个数print(name.count(\"a\")) # 统计字母个数print(name.center(50,\"-\")) #总共打印50个字符，并把nam放在中间，不够的用-补上print(name.endswith(\"ex\")) # 判断字符串以什么结尾name=\"alex \\tname is alex\"print(name.expandtabs(tabsize=30)) # 将name中\\t转为30个空格print(name.find(\"x\")) # 取索引print(name[name.find(\"x\"):]) # 字符串切片name=\"my \\tname is &#123;name&#125; and i am &#123;year&#125; old\"print(name.format(name=\"alex\",year=23))print(name.format_map(&#123;'name':'alex','year':23&#125;))print('ab123'.isalnum()) #isalnum()包含所有字母及数字，如果不是这两个，则为Falseprint('ab123'.isalpha()) # False isalpha()包含纯英文字符print('1A'.isdecimal()) # 是否是十进制 Falseprint('1A'.isdigit()) # 是否是整数 Falseprint('_'.isidentifier()) #判断是否是合法的标识符，实质是否为合法变量名 Trueprint('aasd'.islower()) # 判断是否是小写 Trueprint(''.isspace()) # 是否是空格 Falseprint('My name is'.istitle()) # 字符串首字母大写为title，否则不是print('+'.join(['1','2','3'])) # 对一列表中所有元素进行join操作print(name.ljust(50,'*')) # 左对齐字符串，多余位用*补全print(name.rjust(50,'-')) # 右对齐字符串，多余位用*-补全print('\\n Alex'.lstrip()) # 去掉左边的空格/回车print('\\nAlex\\n'.rstrip()) # 去掉右边的空格/回车print('\\nAlex\\n'.strip()) # 去掉左边和右边的空格/回车print('Alex')p=str.maketrans(\"abcdef\",\"123456\")print(\"alex li\".translate(p)) #把alex li换成上一行对应的值print(\"alex li\".replace('l','L',1)) # 替换 1表示替换几个l,从左到右计算替换个数print(\"alex li\".rfind('l')) # 找到的最右边的下标返回print(\"alex li\".split('l')) # 默认将字符串按照空格分隔成列表，也可以在()中填写相应的分隔符，比如以字符l分隔，print(\"alex li\".split(‘l’)),而且分隔符在列表中不会出现print(\"1+2+3+4\".split('+')) # ['1', '2', '3', '4']print(\"1+2\\n+3+4\".splitlines()) # ['1+2', '+3+4']print(\"Alex Li\".swapcase()) # aLEX lIprint('lex li'.title()) # Lex Liprint('lex li'.zfill(50)) #不够以0填充print('---') 8.字典1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# 字典无序info=&#123; 'stu1101':\"tengxun\", 'stu1102':\"baidu\", 'stu1103':\"ali\",&#125;print(info)# 0.查找# 方法一:确定存在print(info[\"stu1101\"]) # 查找若不在，则报错# 方法二:不确定存在，安全查找方法print(info.get(\"stu11004\")) # 查找不在不会报错，直接返回None，若有直接返回print('stu1103' in info) # True# 1.修改info[\"stu1101\"]=\"腾讯\"print(info)# 2.增加info[\"stu1104\"]=\"zhubajie\"print(info)# 3.删除# 方法一del info[\"stu1101\"]print(info)# 方法二info.pop(\"stu1102\")print(info)'''# 随机删除info.popitem()print(info)'''# 4.多级字典嵌套及操作av_catalog = &#123; \"欧美\":&#123; \"www.youporn.com\": [\"很多免费的,世界最大的\",\"质量一般\"], \"www.pornhub.com\": [\"很多免费的,也很大\",\"质量比yourporn高点\"], \"letmedothistoyou.com\": [\"多是自拍,高质量图片很多\",\"资源不多,更新慢\"], \"x-art.com\":[\"质量很高,真的很高\",\"全部收费,屌比请绕过\"] &#125;, \"日韩\":&#123; \"tokyo-hot\":[\"质量怎样不清楚,个人已经不喜欢日韩范了\",\"听说是收费的\"] &#125;, \"大陆\":&#123; \"1024\":[\"全部免费,真好,好人一生平安\",\"服务器在国外,慢\"] &#125;&#125;b=&#123; 'stu1101':\"Alex\", 1:3, 2:5&#125;info.update(b) #将两个字典合并，存在key,则更新value，不存在key，则合并print(info)print(info.items()) #把一个字典转成列表c=info.fromkeys([6,7,8],\"test\")print(c)c=info.fromkeys([6,7,8],[1,&#123;'name':'alex'&#125;,444])print(c)c[7][1]['name']='Jack Chen' # 3个key共用一个value,修改一个则所有的都修改了print(c)print(\"--------\")av_catalog[\"大陆\"][\"1024\"][1]=\"可以在国内做镜像\" # 二级字典替换av_catalog.setdefault(\"taiwan\",&#123;\"www.baidu.com\":[1,2]&#125;) # 如果不重名，即创建一个新的值，如果重名，将找到的值返回print(av_catalog)print(info.keys()) # 打印出所有的keyprint(info.values()) # 打印出所有的valueprint(\"---------------\")for i in info: print(i,info[i]) #效率更高点print(\"---------------\")for k,v in info.items(): print(k,v) 9.函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115# 1.无参函数# 定义一个函数def fun1(): '''testing''' print('in the fun1') return 1# 定义一个过程 实质就是无返回值的函数def fun2(): '''testing2''' print('in the fun2')x=fun1()y=fun2()print(x)print(y) # 没有返回值得情况下，python隐式地返回一个Noneimport timedef logger(): time_format='%Y-%m-%d %X %A %B %p %I' time_current=time.strftime(time_format) with open('a.txt','a+')as f: f.write('time %s end action\\n'%time_current)def test1(): print('in the test1') logger()def test2(): print('in the test2') logger() return 0def test3(): print('in the test3') logger() return 1,&#123;5:\"sda\",6:\"zad\"&#125;,[1,2,3]x=test1()y=test2()z=test3()print(x) # Noneprint(y) # 0print(z) # (1, &#123;5: 'sda', 6: 'zad'&#125;, [1, 2, 3])'''总结： 返回值数=0:返回None 返回值数=1:返回object 返回值数&gt;1:返回tuple'''# 2.有参函数# 默认参数特点：调用函数的时候，默认参数非必须传递# 用途：1.默认安装值def test(x,y): print(x) print(y)test(1,2) # 位置参数调用 与形参意义对应test(y=1,x=2) # 关键字调用，与形参顺序无关test(3,y=2) # 如果既有关键字调用又有位置参数，前面一个一定是位置参数，一句话：关键参数一定不能写在位置参数前面'''比如加入一个参数z'''def test1(x,y,z): print(x) print(y) print(z)# 关键参数一定不能放在位置参数前面test1(3,4,z=6)test1(3,z=6,y=4)# 默认参数,def test(x,y,z=2): print(x) print(y) print(z)test(1,2)# 用*args传递多个参数，转换成元组的方式 *表示一个功能代号，表示接受的参数不固定，args可以随意起名def test(*args): print(args)test(1,3,4,5,5,6)test(*[1,3,4,5,5,6]) # args=tuple([1,2,3,4,5])def test(x,*args): print(x) print(args)test(1,2,3,4,5,6,7) # 1 (2,3,4,5,6,7)# 字典传值 **kwagrs:把N个关键字参数，转换成字典的方式def test(**kwargs): print(kwargs) print(kwargs['name'],kwargs['age'],kwargs['id'],kwargs['sex'])test(name='alex',age=8,id=10,sex='M') # &#123;'name': 'alex', 'age': 8, 'id': 10, 'sex': 'M'&#125;test(**&#123;'name':'alex','age':8,'id':10,'sex':'M'&#125;)def test(name,**kwargs): print(name) print(kwargs)test('alex',age=18,sex='M') # 字典 &#123;'age': 18, 'sex': 'M'&#125;# 默认参数得放在参数组前面def test(name,age=18,**kwargs): print(name) print(age) print(kwargs)test('alex',sex='M',hobby='tesla',age=3)test('alex',3,sex='M',hobby='tesla')test('alex') # 后面的**kwargs不赋值输出为空字典def test(name,age=18,*args,**kwargs): print(name) print(age) print(args) print(kwargs)test('alex',age=34,sex='M',hobby='tesla') # alex 34 () &#123;'sex': 'M', 'hobby': 'tesla'&#125; 10.高阶函数1234567# 高阶函数 变量可以指向函数，函数的参数能接受变量，那么一个函数就可以接受另一个函数作为参数，这个函数就叫做高阶函数def f(x): return xdef add(x,y,f): return f(x)+f(y)res=add(1,2,f)print(res) # 3","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://guanhonly.github.io/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://guanhonly.github.io/tags/机器学习/"}]},{"title":"HBase原理探究（1）","slug":"hbase-construction1","date":"2018-12-01T12:21:12.000Z","updated":"2019-12-07T13:06:42.676Z","comments":true,"path":"2018/12/01/hbase-construction1/","link":"","permalink":"http://guanhonly.github.io/2018/12/01/hbase-construction1/","excerpt":"","text":"HBase的行、列和列族HBase的最基本的单位是列(column)，一列或多列形成一行(row)，并由唯一的行键(rowkey)来确定存储，rowkey按照字典排序。 一个表(table)中有若干行，其中每列可能有多个版本，这些不同的版本按照时间戳(timestamp)区分。 若干个列构成一个列族(column family)，一个列族中的所有列存储在一个HFile中。列族在创建表时就定义好，不能频繁修改，数量不能太多，而一个列族中的列可以有数百万，列值也没有类型和长度的规定。 列中的值允许为空，有利于存储十分稀疏的数据（这也是与传统关系型数据库相比一个很大的优势）。 关系型数据库和HBase的行列关系如下图： 取某个特定的值可以用table, rowkey, family, column, timestamp。其中timestamp由系统默认指定，也可以由用户使用。读取时优先读取新值。 负载均衡HBase中扩展和负载均衡的基本单元称为region。region为按照行键排列的区间，如果region太大，系统会将他们动态地拆分，相反就会合并多个region。 一张表初始时只有一个region，当用户开始向表中插入数据时，系统会检查这个region大小，如果超过阈值，则会在中间键处将这些region分割开来，拆分成两个大致相等的region。 每一个region只能由一台region server加载，有一个region server可以同时加载多个region。其中region在region server中的分布为分散分布(如下图)。 每个region由多个store构成，一个store保存着一个column family。每个store由一个memStore和0个或多个storefile组成，storefile以HFile的形式存储在hdfs中。memstore用于在内存中缓存一定大小的数据，达到一定大小后批量写入HFile(flush)，数据是有序的。","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"HBase","slug":"HBase","permalink":"http://guanhonly.github.io/tags/HBase/"}]},{"title":"基于hexo的marble模板","slug":"howInstall","date":"2018-12-01T11:36:39.000Z","updated":"2019-03-30T13:07:01.010Z","comments":true,"path":"2018/12/01/howInstall/","link":"","permalink":"http://guanhonly.github.io/2018/12/01/howInstall/","excerpt":"","text":"我的旧版博客使用的模板。项目github地址：hexo-theme-marble 自己动手做的一个github个人主页，由于之前没有做过前端，所以在@ppoffice的Alex项目基础上改的。主要是根据我的个人喜好进行的界面的调整，并增加了评论功能。评论功能采用的gitalk。 整个界面追求极致简洁，黑白配色，所以取名marble。 安装方法：1. nodejs和hexo的安装可以参考这篇博客：用Hexo + github搭建自己的博客 — 再也不用羡慕别人了！ 2. 在你新建的hexo目录下，安装这个主题：1git clone https://github.com/guanhonly/hexo-theme-marble themes/marble marble要求Hexo 2.4及以上版本 3. 更改clone后的marble中的_config.yml，相关参数可见Alex的文档4. gitalk相关配置 首先，去这里申请github的授权，获得client ID和client Secret。 然后，修改 _config.yml中的相关配置：12345678gitalk: enable: true language: # 指定语言，默认从系统中获取 owner: # 申请时的owner admin: # 管理员，如果没有其他人，填自己 github_repo: # 用与保存评论的仓库名，建议填个人主页对应的仓库 client_id: # 刚刚生成的client ID client_secret: # 刚刚生成的client Secret 5. 在个人主页的根目录下，运行1hexo clean 然后运行1hexo g 最后运行1hexo d 过一会儿就可以上看到使用了这个模板的个人主页了 效果： 6.发布新博客在项目根目录下，输入：1hexo new \"PostName\" PostName即为你的这篇博客名称，创建成功的博客文件会在./source/_post中 文章编辑完成后，执行以下命令： 123hexo g //生成静态页面hexo s //在本地预览生成的页面，如果有信息可以不进行这一步hexo d //发布","categories":[{"name":"技术","slug":"技术","permalink":"http://guanhonly.github.io/categories/技术/"}],"tags":[{"name":"实用教程","slug":"实用教程","permalink":"http://guanhonly.github.io/tags/实用教程/"}]},{"title":"关于我","slug":"aboutme","date":"2016-12-31T16:00:00.000Z","updated":"2019-12-07T15:21:01.378Z","comments":false,"path":"2017/01/01/aboutme/","link":"","permalink":"http://guanhonly.github.io/2017/01/01/aboutme/","excerpt":"","text":"Grab（中国）软件工程师。分享技术，分享阅读，分享生活。 欢迎来稿，无论是技术还是你擅长的领域，但必须是markdown格式。如果有离线图片请一并发送，并标明图片在文中的位置。邮箱地址：guanhonly@gmail.com markdown的基本语法可以参考：markdown基本语法 如有转载，请注明出处。博客中的图片大部分来源于网络。","categories":[],"tags":[]}]}